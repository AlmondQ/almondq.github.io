{"meta":{"title":"加油！少年","subtitle":"一切都是最好的安排","description":null,"author":"Almond","url":"blog.almondq.top"},"pages":[{"title":"Categories","date":"2016-07-14T10:23:43.000Z","updated":"2016-07-14T09:54:41.000Z","comments":true,"path":"categories/index.html","permalink":"blog.almondq.top/categories/index.html","excerpt":"","text":""},{"title":"归档","date":"2016-03-26T13:45:16.000Z","updated":"2016-03-26T13:46:42.000Z","comments":true,"path":"archive/index.html","permalink":"blog.almondq.top/archive/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-07-14T10:05:25.000Z","updated":"2016-07-14T09:54:41.000Z","comments":true,"path":"tags/index.html","permalink":"blog.almondq.top/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2016-07-14T10:24:30.000Z","updated":"2016-07-14T10:24:30.000Z","comments":true,"path":"about/index.html","permalink":"blog.almondq.top/about/index.html","excerpt":"","text":"Beginner of Pentest"}],"posts":[{"title":"Same Origin Policy","slug":"Same-Origin-Policy","date":"2016-07-15T07:07:10.000Z","updated":"2016-07-15T07:14:19.000Z","comments":true,"path":"2016/07/15/Same-Origin-Policy/","link":"","permalink":"blog.almondq.top/2016/07/15/Same-Origin-Policy/","excerpt":"同源策略","text":"同源策略 同源策略同源是指域名（根，子），协议，端口都相同，不同源","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"blog.almondq.top/categories/Journey-of-Study/"}],"tags":[{"name":"Web","slug":"Web","permalink":"blog.almondq.top/tags/Web/"}]},{"title":"Beginner of Linux","slug":"Beginner-of-Linux","date":"2016-07-12T06:59:48.000Z","updated":"2016-07-15T09:00:05.000Z","comments":true,"path":"2016/07/12/Beginner-of-Linux/","link":"","permalink":"blog.almondq.top/2016/07/12/Beginner-of-Linux/","excerpt":"一直以来都是零零散散的学了一些linux的命令，现在要系统的学习一下。本篇为系列一，主要学习了一些快捷键，用户和文件权限管理，目录结构文件基本操作，管道，简单文本处理","text":"一直以来都是零零散散的学了一些linux的命令，现在要系统的学习一下。本篇为系列一，主要学习了一些快捷键，用户和文件权限管理，目录结构文件基本操作，管道，简单文本处理 Linux终端Terminal通常在使用Linux时，我们并不是直接与系统打交道，而是通过一个叫做Shell的中间程序来完成，在图形界面下为了实现在一个窗口中完成接受用户输入和显示输出，Linux系统提供了一个叫做终端模拟器的程序(Terminal)。终端本质上对应着Linux上的/dev/tty设备，Linux的多用户登录就是通过不同的/dev/tty设备完成的，Linux默认提供了6个纯命令行界面的”termimnal”(准确的说这里应该是6个virtual consoles)来让用户登录，在物理机系统上可以通过使用[Ctrl]+[Alt]+[F1]~[F6]进行切换。可以使用Ctrl]+[Alt]+[F7]来切换回图形界面 Shell通常在图形界面中对实际体验带来差异的不是终端模拟器，而大都是这个Shell，有壳就有核，这里的核就是指的UNIX/Linux内核，Shell是指“提供给使用者使用界面”的软件(命令解析器)，类似于DOS下的command(命令行)和后来的cmd.exe。普通意义上的Shell就是可以接受用户输入命令的程序。 Unix/Linux操作系统下的Shell既是用户交互的界面，也是控制系统的脚本语言。常见的Shell有bash,zsh,ksh,csh等 一些重要的快捷键 [Tab] 使用Tab键来进行命令补全 [Ctrl+c] 强行终止当前程序 [Ctrl+d] 键盘输入结束或退出终端 [Ctrl+a/e] 将光标移至输入行头/尾 [Ctrl+k] 删除从光标所在位置到行末 [Alt+Backspace] 向前删除一个单词 通配符 * 匹配0或多个字符 ? 匹配任意一个字符 [list] 匹配list中的任意单一字符 [!list] 匹配除list中的任意单字符以外的字符 [c1-c2] 匹配c1-c2中的任意单字符，如[0-9][a-z] {string1,string2,…} 匹配string1或string2或更多其一字符 {c1..c2} 匹配c1-c2中全部字符，如{1-10} 用户及文件权限管理Linux用户管理Linux是一个可以实现多用户登录的操作系统，这些用户共享一些主机的资源，但也分别有自己的用户空间用于存放各自的文件。但实际上他们的文件都是放在同一个物理磁盘上的甚至同一个逻辑分区或者目录里，但是由于Linux的用户管理和权限机制，不同用户不可以轻易的查看和修改他人的文件 查看用户 pts代表当前为伪终端，伪是相对于/dev/tty设备而言的，后边的/0,/1代表着伪终端序号，时间为启动时间 创建用户在Linux系统里，root账户拥有整个系统至高无上的权力，比如新建／添加用户。 root权限，系统权限的一种，与SYSTEM权限可以理解成一个概念，但高于Administrator权限，root时Linux和Unix系统中的超级管理员用户账户，该账户拥有整个系统至高无上的权力，所有对象都可以操作。 我们一般登录系统时都是以普通账户的身份登录的，要创建用户需要root权限，需要用到sudo这个命令。使用sudo命令的两大前提，一是要知道当前登录用户的密码，二是当前用户必须在sudo用户组。 su 可以切换到用户user sudo 可以以特权级别运行cmd命令 su- 切换用户，同时环境变量也会跟着改变成目标用户的环境变量 新建好用户后，即可使用上述命令登录，想退出当前用户可以使用[Ctrl+d] 用户组在Linux里面每个用户都属于一个用户组，用户组简单的理解就是一组用户的集合，它们共享一些资源和权限，同时拥有私有资源。一个用户可以属于多个用户组。查看用户属于哪个用户组有两个方法 使用groups命令创建用户时如果不指定用户组的话，默认会自动创建一个与用户名相同的用户组。有的用户没有显示属于sudo用户组但却可以使用sudo命令获取root权限，这是因为/etc/sudoers.d的目录下创建了该用户的文件。 查看/etc/group文件 /etc/group文件格式说明group_name:password:GID:user_list 将其他用户加入sudo用户组使用usermod命令可以为用户添加用户组 删除用户 Linux文件权限查看文件权限 变更文件所有者在当前文件所有者的角色下在该文件的目录中执行 sudo chown [即将拥有权限的用户名] [文件名] 修改文件权限 方式一：二进制数字表示 每个文件的三组权限（拥有者，用户组，其他用户）分别对应一组”rwx”，也就是一个7，如果当前文件只想当前用户可用，就可以 chmod 700 [文件名] 方式二：加减赋值操作 完成上述相同的效果，可以 chmod go-rw [文件名] “g”代表group “o”代表others “u”代表user “＋”“－”就分表表示增加和去掉相应的权限 Linux目录结构及文件基本操作目录结构UNIX 是以目录为主的，Linux 也继承了这一优良特性。 Linux 是以树形目录结构的形式来构建整个系统的，可以理解为一个用户可操作系统的骨架。虽然本质上无论是目录结构还是操作系统内核都是存储在磁盘上的，但从逻辑上来说 Linux 的磁盘是“挂在”（挂载在）目录上的，每一个目录不仅能使用本地磁盘分区的文件系统，也可以使用网络上的文件系统。举例来说，可以利用网络文件系统（Network File System，NFS）服务器载入某特定目录等。 FHS标准 FHS（英文：Filesystem Hierarchy Standard 中文：文件系统层次结构标准），多数 Linux 版本采用这种文件组织形式，FHS 定义了系统中每个区域的用途、所需要的最小构成的文件和目录同时还给出了例外处理与矛盾处理。FHS 定义了两层规范: 第一层是/ 下面的各个目录应该要放什么文件数据，例如 /etc 应该要放置设置文件，/bin 与 /sbin 则应该要放置可执行文件等等。第二层则是针对 /usr 及 /var 这两个目录的子目录来定义。例如 /var/log 放置系统登录文件、/usr/share 放置共享数据等等。 FHS 依据文件系统使用的频繁与否以及是否允许用户随意改动（注意，不是不能，学习过程中，不要怕这些），将目录定义为四种交互作用的形态，如下表所示： 文件基本操作新建空白文件使用touch命令新建空白文件，使用mkdir新建目录(-p参数代表如果父目录不存在则创建父级目录) 复制和删除使用cp复制文件，使用rm删除文件，-r代表操作目录，-f代表强制删除 移动和重命名使用mv移动文件和为单一文件重命名，使用rename为多个文件重命名 查看文件使用cat正序查看文件，使用tac倒序查看文件，nl命令添加行号并打印，比 cat -n更专业more和less是更专业的用来查看文件的命令，file命令用来查看文件类型 文件打包与压缩只记录最常用的tar解压缩 tar -xf [filename] -c [要解压到的路径] 管道管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)。我们在使用一些过滤程序时经常会用到的就是匿名管道，在命令行中由 | 分隔符表示，例： ls -al /etc | less cut命令打印每一行的某一字段，例：打印/etc/passwd文件中以:为分隔符的第一个字段和第六个字段分别表示用户名和其家目录 cut /etc/passwd -d &apos;:&apos; -f 1,6 grep命令在文本中或stdin中查找匹配字符串，grep命令的一般形势为： grep [命令选项]... 用于匹配的表达式 [文件]... wc命令简单小巧的计数工具，用于统计并输出一个文件中行，单词和字节的数目 wc /etc/passwd sort排序命令cat /etc/passwd | sort cat /etc/passwd | sort -r 反序 cat /etc/passwd | sort -t&apos;:&apos; -k 3 -n uniq去重命令简单的文本处理tr命令可以用来删除一段文本信息中的某些文字或者将其进行转换 tr [option]...SET1 [SET2] 常用选项有 -d 删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配 -s 去除set1注定的在输入文本中连续并重复的字符 col命令可以将Tab换成对等数量的空格键或者反转这个操作 col [option] 常用选项有 -x 将Tab转换为空格 -h 将空格转换为Tab(默认选项) join命令用于将两个文件中包含相同内容的那一行合并在一起 join [option]... file1 file2 常用选项有 -t 指定分隔符，默认为空格 -i 忽略大小写差异 -1 指明第一个文件要用哪个字段来对比，默认对比第一个字段 -2 指明第二个文件要用哪个字段来对比，默认对比第一个字段 paste命令与join命令类似，在不对比数据的情况下，简单地将多个文件合并在一起，以Tab隔开 paste [option] file... 常用选项有 -d 指定合并的分隔符，默为认为Tab -s 不合并到一行，每个文件为一行","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"blog.almondq.top/categories/Journey-of-Study/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"blog.almondq.top/tags/Linux/"}]},{"title":"Go Django","slug":"Go-Django","date":"2016-07-12T06:03:54.000Z","updated":"2016-07-15T02:16:57.000Z","comments":true,"path":"2016/07/12/Go-Django/","link":"","permalink":"blog.almondq.top/2016/07/12/Go-Django/","excerpt":"Python中Web开发框架Django的学习记录","text":"Python中Web开发框架Django的学习记录 0x1 介绍DjangoDjango是一个高效的Web开发框架，提供了通用Web开发模式的高度抽象，提供了频繁进行的编程作业的快速解决方法，以及为“如何解决问题”提供了清晰明了的约定。同时，Django尝试留下了一些方法，可以根据需要在framework之外来开发 主页 https://www.djangoproject.com/ 0x1.1 安装pip install Django==1.9.7","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"blog.almondq.top/categories/Journey-of-Study/"}],"tags":[{"name":"Python","slug":"Python","permalink":"blog.almondq.top/tags/Python/"},{"name":"Django","slug":"Django","permalink":"blog.almondq.top/tags/Django/"}]},{"title":"Web For Pentester","slug":"Web-For-Pentester","date":"2016-07-05T05:01:47.000Z","updated":"2016-07-15T02:22:17.000Z","comments":true,"path":"2016/07/05/Web-For-Pentester/","link":"","permalink":"blog.almondq.top/2016/07/05/Web-For-Pentester/","excerpt":"姜姜姜姜！渗透测试套装Web For Pentester","text":"姜姜姜姜！渗透测试套装Web For Pentester LDAP attacksLDAP(lightweight directory access protocol)用于访问网络中的目录服务 每个LDAP查询使用一个或多个搜索过滤器，它们决定了请求返回的目录项。搜索过滤器可以使用各种逻辑运算符来表示复杂的搜索条件，最常用的过滤器如下： 简单匹配条件：对每个属性的值进行匹配，例如：(username=almond) 析取查询： 指定多个条件，返回的目录项只需要满足其中一个条件即可，例如：(|(cn=XXX)(sn=sss)(on=sss) 合取查询： 指定多个条件，返回的目录项必须满足所有条件，例如：(&amp;(username=almondq)(password=123)) Example 1 一些LDAP服务器授权NULL bind：如果null值被提交给服务器，服务器会绑定连接，php code会认为这个凭据是正确的 为了绑定两个null值，需要把参数全部删除，但是不能以username=&amp;password=这种方式，一定要全部删除，如下图 Example 2 username=hac*&amp;password=hacker 也可以获取授权，在LDAP中用*匹配任意值 But, username=hacker&amp;password=hack* 无法获取，因为密码可能被hashed 所以可以推测过滤器如下： (&amp;(username=[INPUT1])(userPassword=HASH[INPUT2])) 所以可以构造如下输入： hacker))%00(&amp;(username=hacker NULL BYTE%00用来get rid of the end of the filter，此时可以以任何密码授权为hacker，同理： 获得admin授权 File Upload大部分网络应用都有上传功能，如用户头像上传，图片上传，文档上传等，一些实现文件上传功能的代码没有严格限制用户上传的文件后缀以及文件类型，导致允许攻击者上传任意web脚本语言，并能够将这些文件传递给脚本解释器，就可以在远程服务器上执行任意脚本 大多数的文件上传漏洞都会被利用来留下webshell以方便后续进入系统，webshell是以asp，php，jsp活着cgi等网页文件形式存在的一种命令执行环境，也可以称其为一种网页后门，攻击者在入侵了一个网站后，通常会将这些文件与服务器web目录下正常的网页混在一起，然后使用浏览器来访问这些后门，得到一个命令执行环境，以达到控制网站服务器的目的 一句话木马 webshell tool: b374k项目地址： https://github.com/b374k/b374k 使用命令下载到电脑中 git clone https://github.com/b374k/b374k 生成webshell的命令： php index.php -o [shellName].php -p [password] -s -b -z gzcompress -c 9 php index.php -o [shellName].php -p [password] -t garuda -s Example 1这个例子没有任何检查，可以随意上传php文件，此处上传上一节生成的webshell文件 可得到下图 Example 2这个例子进行了后缀检查，无法上传php文件，但是可以通过更改后缀为php3来绕过检查，在其他系统中php4，php5可能也可以成功。也可以在php后缀后面加上服务器(此练习中为apache)无法处理的后缀，比如.php.blah File Include服务器通过php的特性函数去包含任意文件时，由于要包含的这个文件来源过滤不严，从而可以去包含一个恶意文件。文件包含漏洞可分为远程文件包含(RFI)和本地文件包含(LFI)。涉及到的危险函数： include(): 包含并运行指定文件，当包含外部文件发生错误时，系统给出警告，但整个php文件继续执行 require(): 跟include唯一的不同是，当产生错误时，停止执行 include_once(): 与include几乎相同，只是会在导入之前先检测该文件是否已经导入 require_once(): 同上 文件包含漏洞也可以被用作目录遍历来读取任意文件 Example 1 尝试将https://pentesterlab.com/test_include.txt包含在此例中，此txt文件包含phpinfo() 成功出现服务器配置信息 Example 2 此例与1相比，对文件后缀进行了控制，include($_GET(“page”).”.php”)，这种情况下，可以使用%00进行截断，但是这种截断方法只在php5.3.4版本之前有效 上例演示的是本地文件包含，可以用来包含本地敏感文件，或者结合文件上传漏洞 远程文件包含的话，可以在包含的url后边添加?或者&amp;来截断 Command Injection命令注入是因为用作命令一部分的信息缺少过滤或者编码。这些信息可能是用户提交的数据，包括每个url，请求主体参数及cookie，所以要检查每项功能中的所有这些项 不同的命令解释器处理shell元字符的方式各不相同 有两种类型的元字符可以用于在一个现有命令中注入一个独立的命令 字符; | &amp;和换行符用于将几个命令逐个连在一起 反引号(`)用于将一个独立的命令包含在最初的命令处理的数据中（即反引号里面的命令先执行） Example 1 第一个例子没有进行任何过滤，可直接进行命令注入，在参数后边加上 &amp;&amp;(编码为%26) cat /etc/passwd Example 2第二个例子对参数进行了确认，如果在参数后面添加内容会显示无效地址 但是确认机制出现了疏漏，可以通过添加换行符/n（编码为%0a）来截断 Example 3此例进行了跳转。在php中，如果参数的值不符合某些安全限制的话，最简单的方式是用header方法重定向。然而，虽然浏览器进行了跳转，但是这个方法并没有停止执行流程，脚本仍然会以危险的参数完成执行。开发者需要在header方法之后调用die方法来避免这个漏洞 既然浏览器会跳转，所以此例不能用浏览器进行，我选择用telnet 得到的响应文件头会发现状态码为302 但是仍然可以在响应内容中看到cat /etc/passwd的内容","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"blog.almondq.top/categories/Journey-of-Study/"}],"tags":[{"name":"Web","slug":"Web","permalink":"blog.almondq.top/tags/Web/"},{"name":"pentest","slug":"pentest","permalink":"blog.almondq.top/tags/pentest/"}]},{"title":"OOP in Python","slug":"OOP-in-Python","date":"2016-06-15T01:58:14.000Z","updated":"2016-07-15T02:20:23.000Z","comments":true,"path":"2016/06/15/OOP-in-Python/","link":"","permalink":"blog.almondq.top/2016/06/15/OOP-in-Python/","excerpt":"Python中的面向对象编程","text":"Python中的面向对象编程 类类是现实世界的抽象，是对象的定义，实例是真正的实物 创建类123class className(bases): &apos;class documentation string&apos; #&apos;类文档字符串&apos; class_suite #类体 类属性与方法12345class MyClass(object): foo = 100 def myNoActionMethod(self): pass 要知道一个类有哪些属性，有两种方法，第一种是使用dir()内建函数，另外时通过访问类的字典属性dict 12print dir(MyClass)[&apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__doc__&apos;, &apos;__format__&apos;, &apos;__getattribute__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__module__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;foo&apos;, &apos;myNoActionMethod&apos;] 12print MyClass.__dict__&#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;MyClass&apos; objects&gt;, &apos;foo&apos;: 100, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;MyClass&apos; objects&gt;, &apos;__doc__&apos;: None, &apos;myNoActionMethod&apos;: &lt;function myNoActionMethod at 0x1004cf5f0&gt;&#125; 可以看到，dir()返回的仅是对象的属性的一个名字列表，而dict返回的是一个字典，它的键是属性名，键值时相对应的属性对象的数据值 特殊的类属性 实例类被初始化得到实例 初始化mc = MyClass() __init__()构造器方法当类被调用，实例化的第一步是创建实例对象，一旦对象创建了，Python检查是否实现了__init__()方法。默认情况下，如果没有定义（或覆盖）特殊方法__init__()，对实例不会施加任何特别的操作。任何所需的特定操作，都需要程序员实现__init__()，覆盖它的默认行为 然而，如果__init__()已被实现，那么它将被调用，实例对象作为第一个参数self被传递进去，像标准方法调用一样，调用类时，传递的任何参数都交给了__init__() __new__()构造器方法与__init__()相比，__new__()方法更像一个真正的构造器。Python用户可以对内建类型进行派生，因此，需要一种途径来实例化不可变对象，比如派生字符串，数字等。在这种情况下，解释器则调用类的__new__ ()方法，一个静态方法，并且传入的参数是在类实例化操作时生成的。__new__ ()会调用父类的__new__ ()来创建对象 __del__()析构函数只有当一个实例的全部引用都删除之后这个实例的析构函数才会被调用 实例属性 vs 类属性当实例没有和类重名的属性时，可以通过实例访问类属性，但是无法通过实例改变类属性（可变属性：列表，字典除外）","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"blog.almondq.top/categories/Journey-of-Study/"}],"tags":[{"name":"Python","slug":"Python","permalink":"blog.almondq.top/tags/Python/"}]},{"title":"Functions and Functional Programming","slug":"Functions-and-Functional-Programming","date":"2016-06-13T02:02:40.000Z","updated":"2016-07-15T02:20:54.000Z","comments":true,"path":"2016/06/13/Functions-and-Functional-Programming/","link":"","permalink":"blog.almondq.top/2016/06/13/Functions-and-Functional-Programming/","excerpt":"Python的函数与函数式编程","text":"Python的函数与函数式编程 装饰器装饰器实际就是函数，接受函数对象，对该对象进行包装。当包装一个函数的时候，最终会调用它。比如在执行函数之前运行些预备代码，或者在执行之后做些清理工作。例如： 引入日志 增加计时逻辑来检测性能 给函数加入事务的能力 12345678910111213141516171819from time import ctime, sleepdef deco(func): def tsfun(): print &quot;[%s] %s called&quot; % (ctime(), func.__name__) return func() return tsfun@decodef foo(): print &quot;foo self&quot;foo()sleep(4)for i in range(2): sleep(1) foo() 输出结果： 123456[Tue Jun 14 13:25:43 2016] foo calledfoo self[Tue Jun 14 13:25:48 2016] foo calledfoo self[Tue Jun 14 13:25:49 2016] foo calledfoo self deco函数返回一个装饰了func函数的函数 可变长度参数非关键字可变长参数（元祖）12def tupleVarArgs(arg1, arg2=&apos;default&apos;, *theRest): code 关键字变量参数（字典）12def dictVarArgs(arg1, arg2=&apos;default&apos;, *tuples, **theRest): code 函数式编程匿名函数与lambda123test = lambda x, y =2: x + yprint test(3) 结果为5 闭包如果一个内部函数对外部函数的变量进行了引用那么就称为闭包 闭包对于安装计算、隐藏状态和在函数对象和作用域中随意地切换是很有用的 12345678910111213def func(): fs = [] for i in range(1, 4): def g(j): def k(): return j * j return k fs.append(g(i)) return fsg1, g2, g3 = func()print g1(), g2(), g3() 结果：1，4，9","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"blog.almondq.top/categories/Journey-of-Study/"}],"tags":[{"name":"Python","slug":"Python","permalink":"blog.almondq.top/tags/Python/"}]},{"title":"Some Modules in Python","slug":"Some-Modules-in-Python","date":"2016-05-31T02:29:29.000Z","updated":"2016-07-15T02:20:39.000Z","comments":true,"path":"2016/05/31/Some-Modules-in-Python/","link":"","permalink":"blog.almondq.top/2016/05/31/Some-Modules-in-Python/","excerpt":"Python中的一些实用模块","text":"Python中的一些实用模块 1 optparse:提供了命令行参数的解析／处理1.1 示例代码: 12345678910from optparse import OptionParserparser = OptionParser()parser.add_option(&quot;-f&quot;, &quot;--file&quot;, dest=&quot;filename&quot;, \\help=&quot;write report to FILE&quot;, metavar=&quot;FILE&quot;)parser.add_option(&quot;-q&quot;, &quot;--quiet&quot;, dest=&quot;verbose&quot;, \\default=True, help=&quot;do not print status messages to stdout&quot;)(options, args) = parser.parse_args() 命令行输入: 1optp.py -h/--help 输出: 123456Usage: optp.py [options]Options: -h, --help show this help message and exit -f FILE, --file=FILE write report to FILE -q, --quiet do not print status messages to stdout 命令行输入: 12345&lt;yourscript&gt; --file=outfile -q&lt;yourscript&gt; -f outfile --quiet&lt;yourscript&gt; --quiet --file outfile&lt;yourscript&gt; -q -foutfile&lt;yourscript&gt; -qfoutfile optparse支持长选项和短选项，允许短选项混合在一起，允许选项和参数以各种各样的方式联系在一起，所以上面的格式都是正确的 1.2 使用方法首先导入OptionParser类，然后创建一个实例 12from optparser import OptionParserparser = OptionParser() 接着定义选项，基本语法为 1parser.add_option(opt_str, ..., arrt=value, ...) 每个选项有一个或者一个以上的选项字符串，例如-f or –file， 和一些告诉optparse what to expect and 当在命令行遇到该选项应该做什么的选项属性 1parser.add_option(&quot;-f&quot;, &quot;--file&quot;, ...) 最后，一旦定义好了所有的命令行参数，调用parse_args()来解析程序的命令行 1(options, args) = parser.parse_args() 注：也可以传递一个命令行参数列表到parse_args()(但是基本是没有必要的)，否则默认用sys.argv[1:] parse_args()返回两个值： options，一个对象包含所有命令行参数的值 args，由positional arguments组成的列表 这个使用方法cover了四个最重要的选项属性：action，type，dest(destination)，help，其中action是最基础的 ActionAction告诉optparse当在命令行碰到选项是时要做什么。Most actions告诉optparse在一个变量中储存一个值(例如在options的属性中存储命令行中的字符串)，如果不指定选项的action，默认为store最普遍的action是store，告诉optparse取下一个参数(或者现在参数的剩余部分)，确保它是正确的类型，然后把它储存到选择的destination例： 12parser.add_option(&quot;-f&quot;, &quot;--file&quot;, action=&quot;store&quot;, type=&quot;string&quot;,\\dest=&quot;filename&quot;) 现在创造一个假的命令行并要求optparse解析它 12args = [&quot;-f&quot;, &quot;foo.txt&quot;](options, args) = parser.parse_args(args) foo.txt会被存储在options.filename中(that is options.filename=”foo.txt”)optparse支持一些其他的option type：int和float，如果不指定，默认为string 再加上action默认为store，示例可以缩短为： 1parser.add_option(&quot;-f&quot;, &quot;--file&quot;, dest=&quot;filename&quot;) 如果不提供desttination，optparse将选项字符串中figure out一个默认：如果第一个长选项为–foo-bar，则默认destination为foo_bar，如果没有长选项，optparse将看短选项：-f的默认destination是f optparse支持两个分离的action：store_ture和store_false来应对需要把一个变量置为true或者false的情况。这两个值用于处理命令行参数后面不带值的情况，如-v，-q等 12parser.add_option(&quot;-v&quot;, action=&quot;store_true&quot;, dest=&quot;verbose&quot;)parser.add_option(&quot;-q&quot;, action=&quot;store_false&quot;, dest=&quot;verbose&quot;) 这样的话，当解析到-v，options.verbose=Ture, 解析到-q, options.verbose=False 其它action的值还有： store_const: store a constant value append: append this option’s argument to a list count: increment a counter by one callback: call a specified function 默认值当有些期待的命令行参数没有出现的时候，需要给destination设定一个默认值 例：我们想把verbose设定为True除非命令行参数出现-q，可以这样 12parser.add_option(&quot;-v&quot;, action=&quot;store_true&quot;, dest=&quot;verbose&quot;, default=&quot;True&quot;)parser.add_option(&quot;-q&quot;, action=&quot;store_false&quot;, dest=&quot;verbose&quot;) 因为都是作用于同一个destination，下面这种写法与上面等效 12parser.add_option(&quot;-v&quot;, action=&quot;store_true&quot;, dest=&quot;verbose&quot;)parser.add_option(&quot;-q&quot;, action=&quot;store_false&quot;, dest=&quot;verbose&quot;, default=&quot;True&quot;) 当上例中的两条语句中都有default时，以最后一个default为准 一个更清楚的方式是在调用parse_args()方法之前的任意时间调用set_default()方法 123parser.set_default(verbose=True)parser.add_option(...)(options, args) = parser.parse_args() 生成程序帮助和程序版本optparse的另一个实用功能是生成帮助文档，只需要为add_option()方法的help参数制定帮助信息文本。程序版本需要在创建OptionParser对象时指定version参数 123456789101112131415# %prog会被自动替换为当前脚本的名称usage = &quot;usage: %prog [options] arg1 arg2&quot;parser = OptionParser(usage=usage, version=&quot;%prog 1.0&quot;)parser.add_option(&quot;-v&quot;, &quot;--verbose&quot;, action=&quot;store_true&quot;, dest=&quot;verbose&quot;, default=True, help=&quot;make lots of noise [default]&quot;)parser.add_option(&quot;-q&quot;, &quot;--quiet&quot;, action=&quot;store_false&quot;, dest=&quot;verbose&quot;, help=&quot;be vewwy quiet (I&apos;m hunting wabbits)&quot;)parser.add_option(&quot;-f&quot;, &quot;--filename&quot;, metavar=&quot;FILE&quot;, help=&quot;write output to FILE&quot;)parser.add_option(&quot;-m&quot;, &quot;--mode&quot;, default=&quot;intermediate&quot;, help=&quot;interaction mode: novice, intermediate, &quot; &quot;or expert [default: %default]&quot;) 处理异常optparse可以自动探测应处理一些用户异常，用户也可以使用parser.error()方法来自定义一些异常处理 123(options, args) = parser.parse_args()if options.a and options.b: parser.error(&quot;options -a and -b are mutually exclusive&quot;) 如果命令行中-a -b同时存在，则显示”options…”来警告用户 官方文档： https://docs.python.org/2/library/optparse.html# 2 json(JavaScript Object Notation)2.1 基本用法2.1.1 dump()json.dump(obj, fp, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=”utf-8”, default=None, sort_keys=False, **kw) 基于转换表，将obj序列化为json格式的流到fp(一个支持write()的类文件对象) 2.1.2 load()json.load(fp[, encoding[, cls[, object_hook[, parse_float[, parse_int[, parse_constant[, object_pairs_hook[, **kw]]]]]]]]) 根据转换表将fp(一个包含json文档的支持read()的类文件对象)反序列化成python对象 example: 123456import jsonimport osjson_payload = json.load(open(&quot;&quot;.join([os.path.split(os.path.realpath(__file__))[0], &quot;/testjson.json&quot;])))print json_payload Hint: os.path.split(path)将路径分为路径与文件名两部分，os.path.realpath(__file__)为当前脚本的路径 3 hashlib提供不同的secure hash algorithm，包括SHA1，SHA224，SHA256，SHA384，SHA512，MD5 1234import hashlibh = hashlib.new(&quot;md5&quot;, &quot;md5canbeinsteadedbyotheralgorithms&quot;)print h.hexdigest()","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"blog.almondq.top/categories/Journey-of-Study/"}],"tags":[{"name":"Python","slug":"Python","permalink":"blog.almondq.top/tags/Python/"}]},{"title":"MultiThread in Python","slug":"MultiThread-in-Python","date":"2016-05-19T06:24:40.000Z","updated":"2016-07-15T02:17:40.000Z","comments":true,"path":"2016/05/19/MultiThread-in-Python/","link":"","permalink":"blog.almondq.top/2016/05/19/MultiThread-in-Python/","excerpt":"Python中的多线程","text":"Python中的多线程 0x1 多线程？多线程就是多个线程并发执行，提高效率。 0x1.1 进程？线程？进程时程序的一次执行。线程是CPU调度的基本单位，所有线程运行在同一个进程中。 0x1.2 并发执行时各线程间的执行顺序？为了解决这个问题，引入了锁。当某个线程拥有了这个锁它才能够得到执行。这里要提一下线程的生命周期：新建，就绪，运行，堵塞，死亡。当线程不拥有锁的时候，它就处于阻塞状态，在锁定池等待。除锁定池外，还有等待池，等待池是等待一个事件的发生（条件变量），比如等待磁盘I/O的完成，完成后，会通知一个或全部之前等待的线程，于是这些线程进入锁定池。 0x2 在Python中使用线程Python中提供了几个用语多线程编程的模块，包括thread,threading,Queue等。 0x2.1 thread模块python核心编程的作者这样说： 出于以下几点考虑，我们不推荐您使用thread模块。首先，更高级别的threading模块更为先进，对线程的支持更为完善，而且实用thread模块里的属性可能会与threading冲突。其次，低级别的thread模块的同步原语很少（实际上只有一个），而threading模块则有很多。另外一个不要使用thread的原因是，对于你的进程什么时候应该结束完全没有控制，当主线程结束时，所有的线程都要强制结束掉，没有警告也不会有正常的清除工作，threading模块能确保重要的子线程退出后进程才退出。 0x2.2 threading模块 0x2.2.1 守护线程threading模块支持守护线程（thread模块则不）。如果设定一个线程为守护线程则表示这个线程是不重要的，在退出进程时不用等待这个线程退出。设定线程的daemon属性可以定义一个线程为守护进程：在线程开始（调用thread.start()）之前，调用setDaemon()函数（thread.setDaemon(True)）。可以调用thread.isDaemon()函数来判断其daemon标志的值。 0x2.2.2 Thread类用Thread类可以用多种方法来创建线程： 创建一个Thread的实例，传给它一个函数123456789101112131415161718192021222324252627282930313233import threadingfrom time import sleep, ctimeloops = [4, 2]def loop(nloop, nsec): print &quot;start&quot;, nloop, &quot;at&quot;, ctime() sleep(nsec) print &quot;end&quot;, nloop, &quot;at&quot;, ctime()def main(): print &quot;start at&quot;, ctime() nloop = range(len(loops)) threads = [] for i in nloop: t = threading.Thread(target=loop, args=(i, loops[i])) threads.append(t) for i in nloop: threads[i].start() for i in nloop: threads[i].join() print &quot;end at&quot;, ctime()if __name__ == &quot;__main__&quot;: main() 其中要重点标记一下join()这个方法，一开始不是很理解。join()的作用是阻塞进程直到线程执行完毕。此外，join()函数还有个特殊的功能就是设置超时:Thread.join([timeout])，也就是通过传给join一个参数超过这个指定的时间join就不再阻塞进程。只有在要等待线程结束的时候才要调用join()。 创建一个Thread的实例，传给它一个可调用的类对象(更符合面向对象思想)12345678910111213141516171819202122232425262728293031323334353637383940414243import threadingfrom time import sleep, ctimeloops = [4, 2]class ThreadFunc(object): def __init__(self, func, args, name=&apos;&apos;): self.func = func self.args = args self.name = name def __call__(self): apply(self.func, self.args)def loop(nloop, nsec): print &quot;start&quot;, nloop, &quot;at&quot;, ctime() sleep(nsec) print &quot;end&quot;, nloop, &quot;at&quot;, ctime()def main(): print &quot;start at&quot;, ctime() threads = [] nloops = range(len(loops)) for i in nloops: t = threading.Thread(target=ThreadFunc(loop, (i, loops[i]), loop.__name__)) threads.append(t) for t in threads: t.start() for t in threads: t.join() print &quot;end at&quot;, ctime()if __name__ == &apos;__main__&apos;: main() 一个对象可能有很多种方法，将对象传递给Thread类时，调用的是call方法，此方法为线程专门设计。 从Thread派生出一个子类，创建一个这个子类的实例这样做可以更灵活的定制线程对象，而且创建线程的时候也更简单。1234567891011121314151617181920212223242526272829303132333435363738394041424344import threadingfrom time import sleep, ctimeloops = [4, 2]class MyThread(threading.Thread): def __init__(self, func, args, name=&apos;&apos;): threading.Thread.__init__(self) self.func = func self.args = args self.name = name def run(self): apply(self.func, self.args)def loop(nloop, nsec): print &quot;start %d at %s&quot; % (nloop, ctime()) sleep(nsec) print &quot;end %d at %s&quot; % (nloop, ctime())def main(): print &quot;START AT %s&quot; % ctime() threads = [] nloops = range(len(loops)) for i in nloops: t = MyThread(loop, (i, loops[i]), loop.__name__) threads.append(t) for i in threads: i.start() for i in threads: i.join() print &quot;END AT %s&quot; % ctime()if __name__ == &quot;__main__&quot;: main() 与2相比两点改变： 子类构造器一定要先调用父类的构造器 call()名字要改为run() 0x2.3 Queue模块Queue模块可以用来进行线程间通讯，让各个线程之间共享数据。 0x2.4 LockMUTEX = threading.Lock()创建一个锁对象 MUTEX.acquire([timeout])获得锁，可选参数timeout表示超过该时间后通过返回值可以判断是否得到了锁，从而进行一些其他处理 MUTEX.release()释放锁","categories":[{"name":"Journey of Study","slug":"Journey-of-Study","permalink":"blog.almondq.top/categories/Journey-of-Study/"}],"tags":[{"name":"Python","slug":"Python","permalink":"blog.almondq.top/tags/Python/"}]},{"title":"Reflected XSS","slug":"reflected-xss","date":"2016-04-04T01:12:03.000Z","updated":"2016-07-15T01:36:31.000Z","comments":true,"path":"2016/04/04/reflected-xss/","link":"","permalink":"blog.almondq.top/2016/04/04/reflected-xss/","excerpt":"跨站脚本XSS的原理，自动化探查和利用","text":"跨站脚本XSS的原理，自动化探查和利用 0x0 简介HTTP请求中带了攻击脚本，立马就能在HTTP响应中（后台处理的漏洞）有体现。 0x0.1 攻击原理Hacker—发现存在反射XSS的URL—根据输出点的环境构造XSS代码—进行编码、缩短(可有可无，是为了增加迷惑性)—发送给受害人—受害打开后，执行XSS代码—完成hacker想要的功能(获取cookies、url、浏览器信息、IP等等) 0x0.2 触发条件需要欺骗用户自己去点击带有特定参数的链接才能触发 0x0.3 触发原因 没有对输入进行约束，没有对输出进行编码 没有严格区分“数据”和“代码” 0x0.4 可能出现漏洞的地方搜索引擎，错误页面。 0x1 查找并利用0x1.1 查找漏洞确定应用程序所有的用户输入进入点，并遵循以下步骤： 在每个进入点提交一个良性字母字符串 确定此字符串“反射”在应用程序中的所有位置 对于每个反射，确定显示反射数据地方的上下文环境 提交针对上下文环境而修改的数据，尝试在响应中引入任意脚本 如果反射型数据被阻止或净化，导致脚本无法执行，则尝试了解并避开应用程序的防御性过滤","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"blog.almondq.top/tags/Web/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-03-21T00:57:03.000Z","updated":"2016-03-21T00:57:03.000Z","comments":true,"path":"2016/03/21/hello-world/","link":"","permalink":"blog.almondq.top/2016/03/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}